# Update project models and bot functionality
_Exported on 8/28/2025 at 08:12:12 GMT+3 from Cursor (1.5.5)_

---

**User**

В существующий проект внеси изменения. Если файла нет — создай. Если поле уже есть, аккуратно расширь.

0) requirements.txt — убедись, что есть
aiogram>=3.6,<4.0
SQLAlchemy>=2.0
aiosqlite>=0.19
APScheduler>=3.10
python-dotenv>=1.0
pydantic>=2.5
phonenumbers>=8.13
email_validator>=2.1

1) Модели данных — поддержка «Продажи USDT», балансов и аукциона
1.1 app/db/models.py — дополни / поправь

ЗАМЕНИ / ДОПОЛНИ релевантные части следующим (проверь дубли; важна корректировка ForeignKey и новых таблиц):

# app/db/models.py
from __future__ import annotations
import enum
from datetime import datetime
from zoneinfo import ZoneInfo
from sqlalchemy import (
    Boolean, DateTime, Enum as SAEnum, ForeignKey, Integer, Numeric, String, Text,
    text, Index, UniqueConstraint
)
from sqlalchemy.orm import DeclarativeBase, Mapped, mapped_column, relationship

TZ = ZoneInfo("Europe/Amsterdam")
def now_tz() -> datetime: return datetime.now(TZ)

class Base(DeclarativeBase): pass

# ---- Роли ----
class RoleEnum(str, enum.Enum):
    admin = "admin"
    trader = "trader"
    operator = "operator"

# ---- Системные настройки (как ранее) ----
class SystemSettings(Base):
    __tablename__ = "system_settings"
    id: Mapped[int] = mapped_column(primary_key=True, autoincrement=True)
    rub_per_usdt: Mapped[float] = mapped_column(Numeric(18, 6), server_default=text("100.00"))
    service_fee_default_pct: Mapped[float] = mapped_column(Numeric(6, 2), server_default=text("1.00"))
    service_fee_min_pct: Mapped[float] = mapped_column(Numeric(6, 2), server_default=text("0.00"))
    service_fee_max_pct: Mapped[float] = mapped_column(Numeric(6, 2), server_default=text("3.00"))
    service_fee_overridable: Mapped[bool] = mapped_column(Boolean, server_default=text("1"))
    round_secs_default: Mapped[int] = mapped_column(Integer, server_default=text("20"))
    max_tie_rounds_default: Mapped[int] = mapped_column(Integer, server_default=text("5"))
    updated_at: Mapped[datetime] = mapped_column(DateTime(timezone=True), default=now_tz, onupdate=now_tz, nullable=False)
    updated_by: Mapped[int | None] = mapped_column(Integer, nullable=True)

# ---- Аудит ----
class AuditLog(Base):
    __tablename__ = "audit_log"
    id: Mapped[int] = mapped_column(primary_key=True, autoincrement=True)
    actor_tg_id: Mapped[int | None] = mapped_column(Integer, nullable=True)
    actor_role: Mapped[str | None] = mapped_column(String(32), nullable=True)
    action: Mapped[str] = mapped_column(String(64))
    entity: Mapped[str] = mapped_column(String(64))
    before: Mapped[str | None] = mapped_column(Text, nullable=True)
    after: Mapped[str | None] = mapped_column(Text, nullable=True)
    created_at: Mapped[datetime] = mapped_column(DateTime(timezone=True), default=now_tz, nullable=False)

# ---- Пользователи ----
class User(Base):
    __tablename__ = "users"
    id: Mapped[int] = mapped_column(primary_key=True, autoincrement=True)
    tg_id: Mapped[int | None] = mapped_column(Integer, unique=True, index=True, nullable=True)
    role: Mapped[RoleEnum] = mapped_column(SAEnum(RoleEnum), default=RoleEnum.trader, nullable=False)
    is_active: Mapped[bool] = mapped_column(Boolean, server_default=text("0"), nullable=False)
    is_online: Mapped[bool] = mapped_column(Boolean, server_default=text("0"), nullable=False)
    rep: Mapped[int] = mapped_column(Integer, server_default=text("0"), nullable=False)
    balance_rub: Mapped[float] = mapped_column(Numeric(18, 2), server_default=text("0.00"), nullable=False)
    balance_usdt: Mapped[float] = mapped_column(Numeric(18, 2), server_default=text("0.00"), nullable=False)
    reserved_usdt: Mapped[float] = mapped_column(Numeric(18, 2), server_default=text("0.00"), nullable=False)
    created_at: Mapped[datetime] = mapped_column(DateTime(timezone=True), default=now_tz, nullable=False)

# ---- Профиль трейдера / карты (как ранее) ----
class TraderProfile(Base):
    __tablename__ = "trader_profiles"
    id: Mapped[int] = mapped_column(primary_key=True, autoincrement=True)
    external_id: Mapped[str] = mapped_column(String(64), unique=True, index=True)
    nickname: Mapped[str] = mapped_column(String(64))
    full_name: Mapped[str] = mapped_column(String(128))
    phone: Mapped[str] = mapped_column(String(32))
    referral_code: Mapped[str | None] = mapped_column(String(64), nullable=True)
    user_id: Mapped[int | None] = mapped_column(ForeignKey("users.id"), nullable=True)
    created_at: Mapped[datetime] = mapped_column(DateTime(timezone=True), default=now_tz, nullable=False)
    user: Mapped["User"] = relationship()
    cards: Mapped[list["TraderCard"]] = relationship(back_populates="profile", cascade="all, delete-orphan")

class BankEnum(str, enum.Enum):
    TBANK = "ТБАНК"
    ALFABANK = "АЛЬФАБАНК"
    SBERBANK = "СБЕРБАНК"
    VTB = "ВТБ"
    YANDEX = "ЯНДЕКС БАНК"
    OZON = "ОЗОН БАНК"
    OTHER = "ДРУГОЙ БАНК"

class TraderCard(Base):
    __tablename__ = "trader_cards"
    id: Mapped[int] = mapped_column(primary_key=True, autoincrement=True)
    profile_id: Mapped[int] = mapped_column(ForeignKey("trader_profiles.id"), index=True)
    bank: Mapped[BankEnum] = mapped_column(SAEnum(BankEnum), default=BankEnum.TBANK)
    bank_other_name: Mapped[str | None] = mapped_column(String(64), nullable=True)
    card_number: Mapped[str] = mapped_column(String(32))  # хранить в маскируемом виде на UI
    holder_name: Mapped[str] = mapped_column(String(128))
    has_sbp: Mapped[bool] = mapped_column(Boolean, server_default=text("0"), nullable=False)
    sbp_number: Mapped[str | None] = mapped_column(String(64), nullable=True)
    sbp_fullname: Mapped[str | None] = mapped_column(String(128), nullable=True)
    created_at: Mapped[datetime] = mapped_column(DateTime(timezone=True), default=now_tz, nullable=False)
    profile: Mapped["TraderProfile"] = relationship(back_populates="cards")

# ---- Токены доступа ----
class AccessToken(Base):
    __tablename__ = "access_tokens"
    id: Mapped[int] = mapped_column(primary_key=True, autoincrement=True)
    profile_id: Mapped[int] = mapped_column(ForeignKey("trader_profiles.id"), index=True)
    token: Mapped[str] = mapped_column(String(24), unique=True, index=True)
    created_at: Mapped[datetime] = mapped_column(DateTime(timezone=True), default=now_tz, nullable=False)
    consumed_at: Mapped[datetime | None] = mapped_column(DateTime(timezone=True), nullable=True)

# ---- Сделки / Аукцион ----
class DealType(str, enum.Enum):
    BUY = "BUY"     # админ покупает RUB (старый сценарий)
    SELL = "SELL"   # ПРОДАЖА USDT с карты трейдера (этот сценарий)

class DealStatus(str, enum.Enum):
    DRAFT = "DRAFT"
    OPEN = "OPEN"                    # Этап 1 рассылается
    BIDDING = "BIDDING"              # Этап 2/3 идут
    WINNER_ASSIGNED = "WINNER_ASSIGNED"
    WAITING_ADMIN_TRANSFER = "WAITING_ADMIN_TRANSFER"   # админ должен отправить RUB на карту
    WAITING_TRADER_CONFIRM = "WAITING_TRADER_CONFIRM"   # админ подтвердил, ждём подтверждение трейдера
    COMPLETED = "COMPLETED"
    CANCELLED = "CANCELLED"
    CANCELLED_BY_TRADER = "CANCELLED_BY_TRADER"
    CANCELLED_TIMEOUT = "CANCELLED_TIMEOUT"
    REVIEW = "REVIEW"

class Deal(Base):
    __tablename__ = "deals"
    id: Mapped[int] = mapped_column(primary_key=True, autoincrement=True)
    deal_no: Mapped[str] = mapped_column(String(32), unique=True, index=True)
    deal_type: Mapped[DealType] = mapped_column(SAEnum(DealType), default=DealType.SELL, index=True)

    amount_rub: Mapped[float] = mapped_column(Numeric(18, 2))
    amount_usdt_snapshot: Mapped[float] = mapped_column(Numeric(18, 2))

    base_pct: Mapped[float] = mapped_column(Numeric(6, 2))           # верхняя граница ставок
    service_fee_pct: Mapped[float] = mapped_column(Numeric(6, 2))    # снэпшот комиссии сервиса

    # Выбранная победителем карта (снэпшоты)
    winner_card_id: Mapped[int | None] = mapped_column(ForeignKey("trader_cards.id"), nullable=True)
    winner_card_bank: Mapped[str | None] = mapped_column(String(64), nullable=True)
    winner_card_mask: Mapped[str | None] = mapped_column(String(32), nullable=True)
    winner_card_holder: Mapped[str | None] = mapped_column(String(128), nullable=True)

    audience_type: Mapped[str] = mapped_column(String(32))  # all / rep_range / personal
    audience_filter: Mapped[str | None] = mapped_column(String(256), nullable=True)  # JSON

    comment: Mapped[str | None] = mapped_column(String(1000), nullable=True)
    warning_enabled: Mapped[bool] = mapped_column(Boolean, server_default=text("0"))

    round_secs: Mapped[int] = mapped_column(Integer, server_default=text("20"))
    max_tie_rounds: Mapped[int] = mapped_column(Integer, server_default=text("5"))

    pay_deadline_at: Mapped[datetime | None] = mapped_column(DateTime(timezone=True), nullable=True)

    status: Mapped[DealStatus] = mapped_column(SAEnum(DealStatus), index=True, default=DealStatus.DRAFT)
    winner_user_id: Mapped[int | None] = mapped_column(ForeignKey("users.id"), nullable=True)
    winner_bid_pct: Mapped[float | None] = mapped_column(Numeric(6, 2), nullable=True)

    created_at: Mapped[datetime] = mapped_column(DateTime(timezone=True), default=now_tz, nullable=False)

Index("ix_deals_type_status", Deal.deal_type, Deal.status)

# Участники/ставки/раунды
class DealParticipant(Base):
    __tablename__ = "deal_participants"
    id: Mapped[int] = mapped_column(primary_key=True, autoincrement=True)
    deal_id: Mapped[int] = mapped_column(ForeignKey("deals.id"), index=True)
    user_id: Mapped[int] = mapped_column(ForeignKey("users.id"), index=True)
    accepted: Mapped[bool] = mapped_column(Boolean, server_default=text("0"))
    created_at: Mapped[datetime] = mapped_column(DateTime(timezone=True), default=now_tz, nullable=False)
    UniqueConstraint("deal_id", "user_id", name="uq_participant")

class DealRound(Base):
    __tablename__ = "deal_rounds"
    id: Mapped[int] = mapped_column(primary_key=True, autoincrement=True)
    deal_id: Mapped[int] = mapped_column(ForeignKey("deals.id"), index=True)
    round_number: Mapped[int] = mapped_column(Integer, index=True)  # 1=Этап2, 2..=тай-брейки
    started_at: Mapped[datetime] = mapped_column(DateTime(timezone=True), default=now_tz, nullable=False)
    deadline_at: Mapped[datetime] = mapped_column(DateTime(timezone=True), nullable=False)

class Bid(Base):
    __tablename__ = "bids"
    id: Mapped[int] = mapped_column(primary_key=True, autoincrement=True)
    deal_id: Mapped[int] = mapped_column(ForeignKey("deals.id"), index=True)
    user_id: Mapped[int] = mapped_column(ForeignKey("users.id"), index=True)
    round_number: Mapped[int] = mapped_column(Integer, index=True)
    pct: Mapped[float] = mapped_column(Numeric(6, 2))
    created_at: Mapped[datetime] = mapped_column(DateTime(timezone=True), default=now_tz, nullable=False)

Index("ix_bids_deal_round_user", Bid.deal_id, Bid.round_number, Bid.user_id, unique=True)
Index("ix_bids_deal_round_pct", Bid.deal_id, Bid.round_number, Bid.pct)


Примечание по миграции без Alembic (на деве проще пересоздать БД). Если нужно быстро:

ALTER TABLE users ADD COLUMN balance_usdt NUMERIC(18,2) DEFAULT 0.00;
ALTER TABLE users ADD COLUMN reserved_usdt NUMERIC(18,2) DEFAULT 0.00;
ALTER TABLE deals ADD COLUMN deal_type VARCHAR(10) DEFAULT 'SELL';
ALTER TABLE deals ADD COLUMN winner_card_id INTEGER;
ALTER TABLE deals ADD COLUMN winner_card_bank VARCHAR(64);
ALTER TABLE deals ADD COLUMN winner_card_mask VARCHAR(32);
ALTER TABLE deals ADD COLUMN winner_card_holder VARCHAR(128);

2) Балансы и деньги — сервисные функции
2.1 app/utils/money.py — уже есть, дополни helper’ом
# app/utils/money.py
from decimal import Decimal, ROUND_HALF_EVEN, getcontext
getcontext().rounding = ROUND_HALF_EVEN

def bank_round_2(x: float) -> float:
    return float(Decimal(str(x)).quantize(Decimal("0.01")))

2.2 app/services/balance.py — новый файл
# app/services/balance.py
from __future__ import annotations
from sqlalchemy import select, update
from app.db.base import async_session
from app.db.models import User

async def ensure_usdt_margin(user_id: int, need_usdt: float) -> bool:
    async with async_session() as s:
        u = await s.get(User, user_id)
        return float(u.balance_usdt) >= need_usdt

async def reserve_usdt(user_id: int, amount: float) -> bool:
    """Перенос amount из balance_usdt в reserved_usdt. Возвращает True, если успешно."""
    async with async_session() as s:
        u = await s.get(User, user_id)
        if float(u.balance_usdt) < amount: return False
        u.balance_usdt = float(u.balance_usdt) - amount
        u.reserved_usdt = float(u.reserved_usdt) + amount
        await s.commit()
        return True

async def release_usdt(user_id: int, amount: float) -> None:
    """Возврат резерва в баланс."""
    async with async_session() as s:
        u = await s.get(User, user_id)
        u.reserved_usdt = max(0.0, float(u.reserved_usdt) - amount)
        u.balance_usdt = float(u.balance_usdt) + amount
        await s.commit()

async def consume_reserved_usdt(user_id: int, amount: float) -> bool:
    """Окончательное списание из резерва (не возвращаем на баланс)."""
    async with async_session() as s:
        u = await s.get(User, user_id)
        if float(u.reserved_usdt) < amount: return False
        u.reserved_usdt = float(u.reserved_usdt) - amount
        await s.commit()
        return True

3) Валидации / утилиты
3.1 app/utils/validation.py — убедись, что есть (из предыдущего патча)

Добавь маску карты:

# app/utils/validation.py
from email_validator import validate_email, EmailNotValidError

def mask_card(card_number: str) -> str:
    digits = "".join(ch for ch in card_number if ch.isdigit())
    tail = digits[-4:] if len(digits) >= 4 else digits
    return f"**** **** **** {tail}" if tail else "****"

# validate_pay_account / validate_email_addr / validate_decimal_range_step — как было

4) Планировщик — вспомогательные функции для этапов/таймеров
4.1 app/scheduler.py — ДОПОЛНИ

Добавь функции постановки задач: завершение Этапа 1, завершение раунда, тайм-аут оплаты, «окно подтверждения трейдера». Минимальный скелет:

# app/scheduler.py
from __future__ import annotations
from datetime import datetime, timedelta
from zoneinfo import ZoneInfo
from apscheduler.schedulers.asyncio import AsyncIOScheduler
from apscheduler.jobstores.sqlalchemy import SQLAlchemyJobStore

from app.config import settings
from app.db.base import async_session
from app.db.models import Deal, DealStatus, DealRound
from app.logging_setup import logger

scheduler: AsyncIOScheduler | None = None
TZ = ZoneInfo("Europe/Amsterdam")

def get_scheduler() -> AsyncIOScheduler:
    global scheduler
    if scheduler: return scheduler
    scheduler = AsyncIOScheduler(timezone=TZ, jobstores={"default": SQLAlchemyJobStore(url=settings.scheduler_db_url)})
    return scheduler

async def schedule_stage1_end(deal_id: int, after_seconds: int):
    get_scheduler().add_job("app.workers.auction:end_stage1", "date",
                            run_date=datetime.now(TZ)+timedelta(seconds=after_seconds),
                            args=[deal_id], id=f"deal:{deal_id}:stage1", replace_existing=True)

async def schedule_round_end(deal_id: int, round_number: int, after_seconds: int):
    get_scheduler().add_job("app.workers.auction:end_round", "date",
                            run_date=datetime.now(TZ)+timedelta(seconds=after_seconds),
                            args=[deal_id, round_number], id=f"deal:{deal_id}:round:{round_number}",
                            replace_existing=True)

async def schedule_pay_timeout(deal_id: int, after_minutes: int):
    get_scheduler().add_job("app.workers.auction:pay_timeout", "date",
                            run_date=datetime.now(TZ)+timedelta(minutes=after_minutes),
                            args=[deal_id], id=f"deal:{deal_id}:pay", replace_existing=True)

async def schedule_trader_confirm_window(deal_id: int, after_minutes: int = 10):
    get_scheduler().add_job("app.workers.auction:trader_confirm_timeout", "date",
                            run_date=datetime.now(TZ)+timedelta(minutes=after_minutes),
                            args=[deal_id], id=f"deal:{deal_id}:confirm", replace_existing=True)


Примечание: мы используем callable path "app.workers.auction:end_stage1", поэтому создадим модуль app/workers/auction.py ниже.

5) Воркер аукциона — логика этапов/раундов/победителя/таймеров
5.1 app/workers/auction.py — новый
# app/workers/auction.py
from __future__ import annotations
from datetime import datetime, timedelta
from zoneinfo import ZoneInfo
from sqlalchemy import select, func, update, and_, asc
from aiogram import Bot

from app.config import settings
from app.db.base import async_session
from app.db.models import (Deal, DealStatus, DealRound, DealParticipant, Bid, User, TraderCard)
from app.services.balance import reserve_usdt, release_usdt, consume_reserved_usdt
from app.utils.money import bank_round_2
from app.logging_setup import logger

TZ = ZoneInfo("Europe/Amsterdam")

async def _get_bot() -> Bot:
    from app.bot import create_bot_and_dp
    bot, _ = create_bot_and_dp(settings.bot_token)
    return bot

# ---- Завершение Этапа 1: формируем список допущенных и запускаем торги (раунд 1) ----
async def end_stage1(deal_id: int):
    async with async_session() as s:
        deal = await s.get(Deal, deal_id)
        if not deal or deal.status != DealStatus.OPEN:
            return
        deal.status = DealStatus.BIDDING
        # старт раунда 1
        round_secs = int(deal.round_secs or 20)
        dr = DealRound(deal_id=deal.id, round_number=1,
                       started_at=datetime.now(TZ),
                       deadline_at=datetime.now(TZ) + timedelta(seconds=round_secs))
        s.add(dr)
        await s.commit()
    # Запланируем завершение раунда
    from app.scheduler import schedule_round_end
    await schedule_round_end(deal_id, 1, round_secs)

# ---- Завершение любого раунда: определяем минимум, ничьи -> новый раунд/иначе победитель ----
async def end_round(deal_id: int, round_number: int):
    async with async_session() as s:
        deal = await s.get(Deal, deal_id)
        if not deal or deal.status != DealStatus.BIDDING:
            return
        # найти минимальную ставку на этом раунде
        res = await s.execute(select(Bid.pct).where(Bid.deal_id==deal_id, Bid.round_number==round_number).order_by(asc(Bid.pct)))
        rows = [float(r[0]) for r in res.all()]
        if not rows:
            # никто не сделал ставку — отменяем без штрафов
            deal.status = DealStatus.CANCELLED
            await s.commit()
            return
        min_pct = rows[0]
        # кто поставил минимум?
        res2 = await s.execute(select(Bid.user_id).where(Bid.deal_id==deal_id, Bid.round_number==round_number, Bid.pct==min_pct))
        users = [int(r[0]) for r in res2.all()]
        if len(users) > 1:
            # ничья
            if round_number >= int(deal.max_tie_rounds or 5):
                # случайный победитель из ничьей
                import random
                winner_id = random.choice(users)
                deal.winner_user_id = winner_id
                deal.winner_bid_pct = min_pct
                deal.status = DealStatus.WINNER_ASSIGNED
                await s.commit()
                await _after_winner_assigned(s, deal)
                return
            # иначе новый раунд только среди этих пользователей
            next_round = round_number + 1
            dr = DealRound(deal_id=deal.id, round_number=next_round,
                           started_at=datetime.now(TZ),
                           deadline_at=datetime.now(TZ) + timedelta(seconds=int(deal.round_secs or 20)))
            s.add(dr)
            await s.commit()
            from app.scheduler import schedule_round_end
            await schedule_round_end(deal_id, next_round, int(deal.round_secs or 20))
            return
        # один победитель
        winner_id = users[0]
        deal.winner_user_id = winner_id
        deal.winner_bid_pct = min_pct
        deal.status = DealStatus.WINNER_ASSIGNED
        await s.commit()
    await _after_winner_assigned(None, deal_id=deal_id)

async def _after_winner_assigned(s_in: any = None, deal_id: int | None = None, deal: Deal | None = None):
    # Резерв USDT, запрос выбрать карту, старт таймера для админа
    if not deal:
        async with async_session() as s:
            deal = await s.get(Deal, deal_id)
    if not deal: return
    from app.scheduler import schedule_pay_timeout
    # резерв USDT у победителя
    ok = await reserve_usdt(int(deal.winner_user_id), float(deal.amount_usdt_snapshot))
    if not ok:
        # не смогли зарезервировать (параллельная трата) -> отмена
        async with async_session() as s:
            d = await s.get(Deal, deal.id)
            d.status = DealStatus.CANCELLED
            await s.commit()
        return
    # попросим победителя выбрать карту
    bot = await _get_bot()
    await bot.send_message(int(await _winner_tg_id(deal.winner_user_id)),
        f"<b>Вы выиграли аукцион — ПРОДАЖА USDT</b>\n"
        f"Сделка № <code>{deal.deal_no}</code>\n"
        f"Сумма: {float(deal.amount_rub):.2f} RUB (~{float(deal.amount_usdt_snapshot):.2f} USDT)\n"
        f"Ваша ставка: {float(deal.winner_bid_pct):.2f}%\n\n"
        f"Выберите карту, на которую придут RUB: /pick_card {deal.id}")
    # старт общего таймера оплаты для админа
    await schedule_pay_timeout(deal.id, after_minutes=_minutes_from_deadline(deal))

def _minutes_from_deadline(deal: Deal) -> int:
    # в модели мы не храним «минуты» отдельно; можно вычислить по настройке/состоянию
    return 20  # безопасное дефолтное значение; реальное время задаётся при создании сделки (см. handler)

async def pay_timeout(deal_id: int):
    # админ не успел отправить — отмена без штрафа, резервы вернуть
    async with async_session() as s:
        d = await s.get(Deal, deal_id)
        if not d or d.status not in (DealStatus.WINNER_ASSIGNED, DealStatus.WAITING_ADMIN_TRANSFER):
            return
        if d.winner_user_id:
            await release_usdt(int(d.winner_user_id), float(d.amount_usdt_snapshot))
        d.status = DealStatus.CANCELLED_TIMEOUT
        await s.commit()

async def trader_confirm_timeout(deal_id: int):
    # окно подтверждения трейдером истекло — оператор решает вручную; оставим REVIEW
    async with async_session() as s:
        d = await s.get(Deal, deal_id)
        if not d or d.status != DealStatus.WAITING_TRADER_CONFIRM:
            return
        d.status = DealStatus.REVIEW
        await s.commit()

async def _winner_tg_id(user_id: int) -> int:
    async with async_session() as s:
        u = await s.get(User, user_id)
        return int(u.tg_id or 0)


Важно: это «рабочий скелет» воркера. Он опирается на хендлеры (ниже), которые:

создают сделку SELL, шлют Этап 1, ставят schedule_stage1_end;

на старте Этапа 2 выдают запрос ставок допущенным;

принимают ставки в FSM и воркер завершает раунд.

6) Хендлеры — «Продажа USDT»: мастер, этапы, ставки, выбор карты, подтверждения
6.1 app/handlers/admin_deals_sell.py — новый мастер «Продажа USDT»
# app/handlers/admin_deals_sell.py
from __future__ import annotations
from aiogram import Router, F
from aiogram.filters import Command
from aiogram.fsm.state import State, StatesGroup
from aiogram.fsm.context import FSMContext
from aiogram.types import Message, CallbackQuery
from aiogram.utils.keyboard import InlineKeyboardBuilder
from sqlalchemy import select
from datetime import datetime, timedelta
from zoneinfo import ZoneInfo
import json

from app.config import settings
from app.db.base import async_session
from app.db.models import RoleEnum, User, Deal, DealType, DealStatus
from app.handlers.utils import ensure_user
from app.services.settings import get_settings
from app.utils.money import bank_round_2
from app.utils.validation import validate_decimal_range_step
from app.scheduler import schedule_stage1_end

router = Router(name="admin_deals_sell")
TZ = ZoneInfo("Europe/Amsterdam")

class SellStates(StatesGroup):
    amount_rub = State()
    base_pct = State()
    service_fee = State()
    audience = State()
    audience_params = State()
    pay_time = State()
    comment_ask = State()
    comment_text = State()
    warning_toggle = State()
    confirm = State()

def kb_yesno(cb_yes: str, cb_no: str):
    b = InlineKeyboardBuilder()
    b.button(text="Да", callback_data=cb_yes)
    b.button(text="Нет", callback_data=cb_no)
    b.adjust(2); return b.as_markup()

def kb_audience():
    b = InlineKeyboardBuilder()
    b.button(text="Для всех (онлайн + USDT маржа + карта)", callback_data="aud:all")
    b.button(text="По рейтингу", callback_data="aud:rep")
    b.button(text="Персонально", callback_data="aud:per")
    b.adjust(1)
    return b.as_markup()

@router.message(Command("sell"))
async def sell_menu(message: Message, state: FSMContext):
    async with async_session() as s:
        u = await ensure_user(s, message.from_user)
        if u.role != RoleEnum.admin:
            await message.answer("Доступно только администратору.")
            return
    await state.clear()
    await state.set_state(SellStates.amount_rub)
    await message.answer("1) Введите сумму сделки в RUB:")

@router.message(SellStates.amount_rub)
async def step_amount(message: Message, state: FSMContext):
    try:
        rub = float((message.text or "").replace(" ", "").replace(",", "."))
        if rub <= 0: raise ValueError
        s = await get_settings()
        usdt = bank_round_2(rub / float(s.rub_per_usdt))
        await state.update_data(amount_rub=bank_round_2(rub), amount_usdt=usdt)
        await state.set_state(SellStates.base_pct)
        await message.answer(f"USDT эквивалент: ~ {usdt:.2f}\n2) Вознаграждение трейдера, % (−5.00..+25.00):")
    except Exception:
        await message.answer("Некорректная сумма. Повторите ввод.")

@router.message(SellStates.base_pct)
async def step_base_pct(message: Message, state: FSMContext):
    try:
        v = float((message.text or "").replace(",", "."))
        if not validate_decimal_range_step(v, -5.00, 25.00, 0.01): raise ValueError
        await state.update_data(base_pct=round(v,2))
        s = await get_settings()
        if s.service_fee_overridable:
            await state.set_state(SellStates.service_fee)
            await message.answer(f"3) Комиссия сервиса, % (диапазон {s.service_fee_min_pct:.2f}..{s.service_fee_max_pct:.2f}), шаг 0.01.\nПо умолчанию {s.service_fee_default_pct:.2f}%")
        else:
            await state.update_data(service_fee_pct=float(s.service_fee_default_pct))
            await state.set_state(SellStates.audience)
            await message.answer("4) Выберите аудиторию:", reply_markup=kb_audience())
    except Exception:
        await message.answer("Неверное значение. Введите в диапазоне −5.00..+25.00 с шагом 0.01.")

@router.message(SellStates.service_fee)
async def step_service_fee(message: Message, state: FSMContext):
    from app.services.settings import get_settings
    s = await get_settings()
    try:
        v = float((message.text or "").replace(",", "."))
        if not validate_decimal_range_step(v, float(s.service_fee_min_pct), float(s.service_fee_max_pct), 0.01): raise ValueError
        await state.update_data(service_fee_pct=round(v,2))
        await state.set_state(SellStates.audience)
        await message.answer("4) Выберите аудиторию:", reply_markup=kb_audience())
    except Exception:
        await message.answer(f"Неверно. Введите значение в диапазоне {float(s.service_fee_min_pct):.2f}..{float(s.service_fee_max_pct):.2f} с шагом 0.01.")

@router.callback_query(SellStates.audience, F.data.startswith("aud:"))
async def step_audience(cq: CallbackQuery, state: FSMContext):
    mode = cq.data.split(":",1)[1]
    await state.update_data(audience_type=mode)
    if mode == "rep":
        await state.set_state(SellStates.audience_params)
        await cq.message.answer("Укажите REP диапазон: 'от до' (можно оставить пустым один конец). Пример: '10 100' или '10' или ' 100'")
    elif mode == "per":
        await state.set_state(SellStates.audience_params)
        await cq.message.answer("Укажите telegram_id трейдера:")
    else:
        await state.set_state(SellStates.pay_time)
        await cq.message.answer("5) Время на сделку (мин): 5/10/15/20/25/30")
    await cq.answer()

@router.message(SellStates.audience_params)
async def step_audience_params(message: Message, state: FSMContext):
    data = (message.text or "").strip()
    aud = (await state.get_data())["audience_type"]
    filt = {}
    if aud == "rep":
        parts = data.split()
        if len(parts) == 2:
            filt = {"rep_min": int(parts[0]), "rep_max": int(parts[1])}
        elif len(parts) == 1:
            try:
                v = int(parts[0]); filt = {"rep_min": v}
            except: filt = {"rep_max": int(parts[0])}
        else:
            filt = {}
    elif aud == "per":
        try:
            filt = {"telegram_id": int(data)}
        except:
            await message.answer("Неверный telegram_id.")
            return
    await state.update_data(audience_filter=filt)
    await state.set_state(SellStates.pay_time)
    await message.answer("5) Время на сделку (мин): 5/10/15/20/25/30")

@router.message(SellStates.pay_time)
async def step_pay_time(message: Message, state: FSMContext):
    try:
        mins = int((message.text or "").strip())
        if mins not in (5,10,15,20,25,30): raise ValueError
        await state.update_data(pay_mins=mins)
        await state.set_state(SellStates.comment_ask)
        await message.answer("6) Комментарий к сделке? (Да/Нет)", reply_markup=InlineKeyboardBuilder().row(
            InlineKeyboardBuilder().button(text="Да", callback_data="cmt:yes").button(text="Нет", callback_data="cmt:no").as_markup().inline_keyboard[0]
        ))
    except Exception:
        await message.answer("Введите одно из значений: 5/10/15/20/25/30.")

@router.callback_query(SellStates.comment_ask, F.data.startswith("cmt:"))
async def step_comment_ask(cq: CallbackQuery, state: FSMContext):
    yn = cq.data.split(":",1)[1]
    if yn == "yes":
        await state.set_state(SellStates.comment_text)
        await cq.message.answer("Введите комментарий (до 1000 символов).")
    else:
        await state.update_data(comment=None)
        await state.set_state(SellStates.warning_toggle)
        await cq.message.answer("7) Добавить предупреждение? (Да/Нет)", reply_markup=InlineKeyboardBuilder().row(
            InlineKeyboardBuilder().button(text="Да", callback_data="warn:yes").button(text="Нет", callback_data="warn:no").as_markup().inline_keyboard[0]
        ))
    await cq.answer()

@router.message(SellStates.comment_text)
async def step_comment_text(message: Message, state: FSMContext):
    txt = (message.text or "").strip()
    if len(txt) > 1000:
        await message.answer("Слишком длинно. До 1000 символов.")
        return
    await state.update_data(comment=txt)
    await state.set_state(SellStates.warning_toggle)
    await message.answer("7) Добавить предупреждение? (Да/Нет)", reply_markup=InlineKeyboardBuilder().row(
        InlineKeyboardBuilder().button(text="Да", callback_data="warn:yes").button(text="Нет", callback_data="warn:no").as_markup().inline_keyboard[0]
    ))

@router.callback_query(SellStates.warning_toggle, F.data.startswith("warn:"))
async def step_warning(cq: CallbackQuery, state: FSMContext):
    yn = cq.data.split(":",1)[1]
    await state.update_data(warning_enabled=(yn=="yes"))
    data = await state.get_data()
    # подтверждение
    await state.set_state(SellStates.confirm)
    s = await get_settings()
    usdt = data["amount_usdt"]; rub = data["amount_rub"]
    txt = (
        "<b>Подтверждение сделки — ПРОДАЖА USDT</b>\n"
        f"Сумма: {rub:.2f} RUB (~{usdt:.2f} USDT)\n"
        f"Вознаграждение (база): {data['base_pct']:.2f}%\n"
        f"Комиссия сервиса: {data.get('service_fee_pct', float(s.service_fee_default_pct)):.2f}%\n"
        f"Аудитория: {data.get('audience_type')}\n"
        f"Комментарий: {data.get('comment') or '-'}\n"
        f"Предупреждение: {'вкл' if data.get('warning_enabled') else 'выкл'}\n"
        f"Время на сделку: {data['pay_mins']} мин"
    )
    b = InlineKeyboardBuilder()
    b.button(text="Опубликовать", callback_data="sell:publish")
    b.button(text="Отмена", callback_data="sell:cancel")
    b.adjust(2)
    await cq.message.answer(txt, reply_markup=b.as_markup())
    await cq.answer()

@router.callback_query(SellStates.confirm, F.data.startswith("sell:"))
async def publish_sell(cq: CallbackQuery, state: FSMContext):
    act = cq.data.split(":",1)[1]
    if act == "cancel":
        await state.clear()
        await cq.message.answer("Отменено.")
        await cq.answer(); return
    data = await state.get_data()
    s = await get_settings()

    # номер сделки
    deal_no = datetime.now(TZ).strftime("%Y%m%d-") + __import__("secrets").token_hex(4).upper()[:7]
    service_fee_pct = float(data.get("service_fee_pct", float(s.service_fee_default_pct)))

    async with async_session() as ss:
        u = await ensure_user(ss, cq.from_user)
        if u.role != RoleEnum.admin:
            await cq.answer("Только для администратора", show_alert=True); return

        deal = Deal(
            deal_no=deal_no,
            deal_type=DealType.SELL,
            amount_rub=float(data["amount_rub"]),
            amount_usdt_snapshot=float(data["amount_usdt"]),
            base_pct=float(data["base_pct"]),
            service_fee_pct=service_fee_pct,
            audience_type=data["audience_type"],
            audience_filter=json.dumps(data.get("audience_filter") or {}),
            comment=data.get("comment"),
            warning_enabled=bool(data.get("warning_enabled", False)),
            round_secs=int(s.round_secs_default),
            max_tie_rounds=int(s.max_tie_rounds_default),
            status=DealStatus.OPEN,
        )
        ss.add(deal)
        await ss.commit()

    await state.clear()
    await cq.message.answer(f"Сделка опубликована: ПРОДАЖА USDT\n№ <code>{deal_no}</code>\n"
                            f"{data['amount_rub']:.2f} RUB (~{data['amount_usdt']:.2f} USDT)\n"
                            f"База: {data['base_pct']:.2f}% • Комиссия сервиса: {service_fee_pct:.2f}%\n"
                            f"Время на сделку: {data['pay_mins']} мин")

    # Рассылка Этапа 1 + постановка завершения Этапа 1
    from app.handlers.sell_auction import broadcast_stage1
    await broadcast_stage1(int(deal.id))
    await schedule_stage1_end(int(deal.id), after_seconds=int(s.round_secs_default))
    await cq.answer()

6.2 app/handlers/sell_auction.py — рассылка Этап 1, приём «Принять/Отклонить», запуск Этапа 2, ставки
# app/handlers/sell_auction.py
from __future__ import annotations
from aiogram import Router, F
from aiogram.types import Message, CallbackQuery
from aiogram.filters import Command
from aiogram.fsm.state import State, StatesGroup
from aiogram.fsm.context import FSMContext
from aiogram.utils.keyboard import InlineKeyboardBuilder
from sqlalchemy import select, and_
from datetime import datetime
from zoneinfo import ZoneInfo
import json

from app.db.base import async_session
from app.db.models import (Deal, DealType, DealStatus, DealParticipant, User, Bid, DealRound)
from app.services.settings import get_settings
from app.services.balance import ensure_usdt_margin
from app.handlers.utils import ensure_user
from app.utils.money import bank_round_2

router = Router(name="sell_auction")
TZ = ZoneInfo("Europe/Amsterdam")

class BidStates(StatesGroup):
    waiting_bid = State()  # пользователь вводит ставку для конкретной сделки

# ===== Этап 1: Рассылка =====
async def eligible_traders(deal: Deal) -> list[int]:
    async with async_session() as s:
        q = select(User.tg_id, User.id, User.is_online, User.balance_usdt).where(
            User.role=="trader", User.is_active==True, User.is_online==True
        )
        rows = (await s.execute(q)).all()
        # фильтры аудитории
        filt = json.loads(deal.audience_filter or "{}")
        out = []
        for tg_id, uid, online, busdt in rows:
            if not online: continue
            if float(busdt) < float(deal.amount_usdt_snapshot): continue
            # карта: допустим наличие карты проверим позже при выборе (или здесь — опционально)
            # репутация
            if deal.audience_type == "rep":
                rep_q = await s.execute(select(User.rep).where(User.id==uid))
                rep = int(rep_q.scalar() or 0)
                if "rep_min" in filt and rep < int(filt["rep_min"]): continue
                if "rep_max" in filt and rep > int(filt["rep_max"]): continue
            if deal.audience_type == "personal":
                if int(filt.get("telegram_id", 0)) != int(tg_id): continue
            out.append(int(tg_id))
        return out

def stage1_kb(deal_id: int):
    b = InlineKeyboardBuilder()
    b.button(text="Принять сделку (+1 REP)", callback_data=f"sell1:accept:{deal_id}")
    b.button(text="Отклонить сделку (-2 REP)", callback_data=f"sell1:decline:{deal_id}")
    b.button(text="⏳ ТАЙМЕР", callback_data="noop")
    b.adjust(1,1,1)
    return b.as_markup()

async def broadcast_stage1(deal_id: int):
    from app.bot import create_bot_and_dp
    from app.utils.money import bank_round_2
    bot, _ = create_bot_and_dp("")
    async with async_session() as s:
        d = await s.get(Deal, deal_id)
        sset = await get_settings()
        # готовим текст
        max_reward = 0.0
        if float(d.base_pct) > 0:
            max_reward = bank_round_2(float(d.amount_rub) * float(d.base_pct)/100.0)
        txt = (
            "<b>ВЫ УЧАСТВУЕТЕ В АУКЦИОНЕ!</b>\n"
            "Вид сделки: <b>ПРОДАЖА USDT</b>\n"
            f"Номер: <code>{d.deal_no}</code>\n"
            f"Вознаграждение (база): {float(d.base_pct):.2f}%\n"
            f"Сумма: {float(d.amount_rub):.2f} RUB (~{float(d.amount_usdt_snapshot):.2f} USDT)\n"
            f"Макс. вознаграждение (RUB): {max_reward:.2f}\n"
            f"Комиссия сервиса: {float(d.service_fee_pct):.2f}%\n"
            f"Время сделки: {int(sset.round_secs_default)} сек для Этапа 1; оплата: {int( (d.pay_deadline_at is not None) or 0)}\n"
            + (f"\n<b>Комментарий:</b>\n{d.comment}\n" if d.comment else "") +
            ("\n<b>!ПРЕДУПРЕЖДЕНИЕ!</b>\n!Перевод только на карту трейдера!\n!Перевод с другого банка — риск задержек/комиссий!\n" if d.warning_enabled else "") +
            "\nДИСКЛЕЙМЕР"
        )
        # отправка
        tg_ids = await eligible_traders(d)
        for tg_id in tg_ids:
            try:
                await bot.send_message(tg_id, txt, reply_markup=stage1_kb(d.id))
            except Exception:
                continue

@router.callback_query(F.data.startswith("sell1:"))
async def stage1_click(cq: CallbackQuery):
    _, action, deal_id_s = cq.data.split(":",2)
    deal_id = int(deal_id_s)
    async with async_session() as s:
        u = await ensure_user(s, cq.from_user)
        d = await s.get(Deal, deal_id)
        if not d or d.status != DealStatus.OPEN:
            await cq.answer("Сделка недоступна.", show_alert=True); return
        # маржинальное требование по USDT
        if not await ensure_usdt_margin(u.id, float(d.amount_usdt_snapshot)):
            await cq.answer("Недостаточно USDT для участия.", show_alert=True); return
        # записываем участие
        exist = await s.scalar(select(DealParticipant).where(DealParticipant.deal_id==deal_id, DealParticipant.user_id==u.id))
        if not exist:
            p = DealParticipant(deal_id=deal_id, user_id=u.id, accepted=(action=="accept"))
            s.add(p)
        else:
            exist.accepted = (action=="accept")
        # REP
        if action == "accept": u.rep += 1
        else: u.rep -= 2
        await s.commit()
    if action == "accept":
        await cq.message.answer("Отлично! Вы получили +1 REP. Ждите второй этап… ⏳")
    else:
        await cq.message.answer("Очень жаль: −2 REP. Ожидайте другие сделки.")
    await cq.answer()

# ===== Этап 2: приём ставок (FSM) =====
def bid_range_hint(base_pct: float) -> str:
    lo, hi = -5.00, base_pct
    return f"Введите вашу ставку в диапазоне [{lo:.2f}; {hi:.2f}] с шагом 0.01"

@router.message(Command("bid"))
async def bid_help(message: Message):
    await message.answer("Команда для ставки активируется автоматически в Этапе 2.")

# Воркфлоу Этапа 2: по старту раунда воркер создаёт DealRound; мы шлём допущенным инструкцию «введите ставку»
async def notify_round_start(deal_id: int, round_number: int):
    from app.bot import create_bot_and_dp
    bot, _ = create_bot_and_dp("")
    async with async_session() as s:
        d = await s.get(Deal, deal_id)
        if not d: return
        # список допущенных (accepted)
        rows = await s.execute(select(DealParticipant, User.tg_id).join(User, DealParticipant.user_id==User.id)
                               .where(DealParticipant.deal_id==deal_id, DealParticipant.accepted==True))
        for p, tg_id in rows.all():
            try:
                await bot.send_message(int(tg_id),
                    f"<b>АУКЦИОН НАЧАЛСЯ — РАУНД {round_number}</b>\n"
                    f"{bid_range_hint(float(d.base_pct))}\n"
                    f"Отправьте число (например 0.25 или -1.50).")
            except Exception:
                continue

@router.message(BidStates.waiting_bid)
async def accept_bid(message: Message, state: FSMContext):
    data = await state.get_data()
    deal_id = int(data.get("deal_id"))
    try:
        v = float((message.text or "").replace(",", "."))
    except:
        await message.answer("Нужно число. Пример: 0.25 или -2.00"); return
    async with async_session() as s:
        d = await s.get(Deal, deal_id)
        if not d or d.status != DealStatus.BIDDING:
            await message.answer("Приём ставок закрыт."); return
        lo, hi = -5.00, float(d.base_pct)
        # валидация диапазона и шага 0.01
        if v < lo or v > hi or abs(round(v*100) - v*100) > 1e-9:
            await message.answer(bid_range_hint(float(d.base_pct))); return
        # текущий раунд
        r = await s.scalar(select(DealRound).where(DealRound.deal_id==deal_id).order_by(DealRound.round_number.desc()).limit(1))
        if not r:
            await message.answer("Техническая пауза. Попробуйте позже."); return
        # сохранить ставку (последняя перезаписывает)
        exist = await s.scalar(select(Bid).where(Bid.deal_id==deal_id, Bid.round_number==r.round_number, Bid.user_id== (await s.scalar(select(User.id).where(User.tg_id==message.from_user.id)))))
        if exist:
            exist.pct = round(v,2)
        else:
            uid = await s.scalar(select(User.id).where(User.tg_id==message.from_user.id))
            s.add(Bid(deal_id=deal_id, round_number=r.round_number, user_id=uid, pct=round(v,2)))
        await s.commit()
    await message.answer("Ставка принята.")



ВАЖНО: воркер end_stage1() после смены статуса на BIDDING должен вызвать notify_round_start(deal_id, 1). Добавь в конец end_stage1:

from app.handlers.sell_auction import notify_round_start
await notify_round_start(deal_id, 1)


И аналогично для тай-брейков в end_round — после создания нового DealRound:

from app.handlers.sell_auction import notify_round_start
await notify_round_start(deal_id, next_round)

6.3 Выбор карты победителем, подтверждения и финализация

Создай app/handlers/sell_winner.py:

# app/handlers/sell_winner.py
from __future__ import annotations
from aiogram import Router, F
from aiogram.filters import Command
from aiogram.types import Message, CallbackQuery
from aiogram.utils.keyboard import InlineKeyboardBuilder
from sqlalchemy import select, update
from datetime import datetime, timedelta
from zoneinfo import ZoneInfo

from app.db.base import async_session
from app.db.models import (Deal, DealStatus, TraderProfile, TraderCard, User)
from app.handlers.utils import ensure_user
from app.utils.validation import mask_card
from app.services.balance import release_usdt, consume_reserved_usdt
from app.utils.money import bank_round_2
from app.scheduler import schedule_trader_confirm_window

router = Router(name="sell_winner")
TZ = ZoneInfo("Europe/Amsterdam")

def cards_kb(cards: list[TraderCard], deal_id: int):
    b = InlineKeyboardBuilder()
    for c in cards:
        bank_name = c.bank.value if c.bank.name != "OTHER" else (c.bank_other_name or "ДРУГОЙ БАНК")
        b.button(text=f"{bank_name} • {mask_card(c.card_number)}", callback_data=f"pick:{deal_id}:{c.id}")
    b.adjust(1); return b.as_markup()

@router.message(Command("pick_card"))
async def pick_card_cmd(message: Message):
    # /pick_card <deal_id>
    parts = (message.text or "").split()
    if len(parts) != 2:
        await message.answer("Использование: /pick_card <deal_id>"); return
    deal_id = int(parts[1])
    async with async_session() as s:
        u = await ensure_user(s, message.from_user)
        d = await s.get(Deal, deal_id)
        if not d or d.winner_user_id != u.id:
            await message.answer("Недоступно."); return
        # карты
        prof = await s.scalar(select(TraderProfile).where(TraderProfile.user_id==u.id))
        cards = (await s.execute(select(TraderCard).where(TraderCard.profile_id==prof.id))).scalars().all()
        if not cards:
            await message.answer("У вас нет карт. Обратитесь к администратору."); return
        await message.answer("Выберите карту для получения RUB:", reply_markup=cards_kb(cards, deal_id))

@router.callback_query(F.data.startswith("pick:"))
async def pick_card_cb(cq: CallbackQuery):
    _, deal_id_s, card_id_s = cq.data.split(":",2)
    deal_id, card_id = int(deal_id_s), int(card_id_s)
    async with async_session() as s:
        u = await ensure_user(s, cq.from_user)
        d = await s.get(Deal, deal_id)
        if not d or d.winner_user_id != u.id:
            await cq.answer("Недоступно.", show_alert=True); return
        c = await s.get(TraderCard, card_id)
        if not c:
            await cq.answer("Карта не найдена.", show_alert=True); return
        # Снэпшоты карты
        bank_name = c.bank.value if c.bank.name != "OTHER" else (c.bank_other_name or "ДРУГОЙ БАНК")
        d.winner_card_id = c.id
        d.winner_card_bank = bank_name
        d.winner_card_mask = mask_card(c.card_number)
        d.winner_card_holder = c.holder_name
        d.status = DealStatus.WAITING_ADMIN_TRANSFER
        await s.commit()
    await cq.message.answer(
        "<b>Карта сохранена</b>\n"
        f"Банк: {d.winner_card_bank}\n"
        f"Карта: {d.winner_card_mask}\n"
        f"Держатель: {d.winner_card_holder}\n\n"
        "Ожидайте перевода от администратора."
    )
    # уведомить администратора(ов)
    from app.config import settings
    from app.bot import create_bot_and_dp
    bot, _ = create_bot_and_dp("")
    text_admin = (
        "<b>ПРОДАЖА USDT — переведите RUB победителю</b>\n"
        f"Сделка № <code>{d.deal_no}</code>\n"
        f"Сумма: {float(d.amount_rub):.2f} RUB (~{float(d.amount_usdt_snapshot):.2f} USDT)\n"
        f"Карта: {d.winner_card_bank} • {d.winner_card_mask} • {d.winner_card_holder}\n"
        f"Комментарий: {d.comment or '-'}"
    )
    for admin in settings.admins:
        try:
            await bot.send_message(admin, text_admin, reply_markup=InlineKeyboardBuilder().row(
                InlineKeyboardBuilder().button(text="Перевод выполнен", callback_data=f"adm:paid:{deal_id}"),
                InlineKeyboardBuilder().button(text="Проблема с картой", callback_data=f"adm:card:{deal_id}")
            ).as_markup())
        except Exception:
            continue
    await cq.answer()

@router.callback_query(F.data.startswith("adm:paid:"))
async def admin_paid(cq: CallbackQuery):
    deal_id = int(cq.data.split(":",2)[2])
    async with async_session() as s:
        d = await s.get(Deal, deal_id)
        if not d: return await cq.answer()
        d.status = DealStatus.WAITING_TRADER_CONFIRM
        await s.commit()
    # окно подтверждения трейдера (10 мин)
    await schedule_trader_confirm_window(deal_id, after_minutes=10)
    await cq.message.answer("Ок. Ожидаем подтверждение от трейдера.")
    await cq.answer()

@router.callback_query(F.data.startswith("adm:card:"))
async def admin_card_issue(cq: CallbackQuery):
    deal_id = int(cq.data.split(":",2)[2])
    async with async_session() as s:
        d = await s.get(Deal, deal_id)
        if not d: return await cq.answer()
        # пауза таймера не реализована детально — можно просто отложить задачу вручную
        await cq.message.answer("Отмечено. Свяжитесь с трейдером для смены карты.")
    await cq.answer()

def winner_actions_kb(deal_id: int):
    b = InlineKeyboardBuilder()
    b.button(text="Я ПОЛУЧИЛ ПЕРЕВОД", callback_data=f"win:got:{deal_id}")
    b.button(text="СМЕНИТЬ КАРТУ", callback_data=f"win:card:{deal_id}")
    b.button(text="ОТМЕНА СДЕЛКИ −200 RUB", callback_data=f"win:cancel:{deal_id}")
    b.button(text="ОПЕРАТОР", callback_data=f"win:op:{deal_id}")
    b.adjust(1,2,1); return b.as_markup()

@router.callback_query(F.data.startswith("win:got:"))
async def winner_got_money(cq: CallbackQuery):
    deal_id = int(cq.data.split(":",2)[2])
    async with async_session() as s:
        d = await s.get(Deal, deal_id)
        if not d or d.status not in (DealStatus.WAITING_ADMIN_TRANSFER, DealStatus.WAITING_TRADER_CONFIRM):
            await cq.answer("Недоступно.", show_alert=True); return
        # финальные расчёты
        reward_rub = bank_round_2(float(d.amount_rub) * float(d.winner_bid_pct)/100.0)
        fee_rub = bank_round_2(reward_rub * float(d.service_fee_pct)/100.0) if reward_rub > 0 else 0.0
        # списать резерв USDT
        await consume_reserved_usdt(int(d.winner_user_id), float(d.amount_usdt_snapshot))
        # применить вознаграждение к RUB-балансу победителя
        u = await s.get(User, int(d.winner_user_id))
        if reward_rub >= 0:
            u.balance_rub = float(u.balance_rub) + (reward_rub - fee_rub)
        else:
            u.balance_rub = float(u.balance_rub) - abs(reward_rub)
        d.status = DealStatus.COMPLETED
        await s.commit()
    await cq.message.answer("Сделка завершена. Спасибо!")
    await cq.answer()

@router.callback_query(F.data.startswith("win:cancel:"))
async def winner_cancel(cq: CallbackQuery):
    deal_id = int(cq.data.split(":",2)[2])
    async with async_session() as s:
        d = await s.get(Deal, deal_id)
        if not d: return
        # штраф −200 RUB, резерв USDT вернуть
        u = await s.get(User, int(d.winner_user_id))
        u.balance_rub = float(u.balance_rub) - 200.0
        await release_usdt(int(d.winner_user_id), float(d.amount_usdt_snapshot))
        d.status = DealStatus.CANCELLED_BY_TRADER
        await s.commit()
    await cq.message.answer("Сделка отменена. Штраф −200 RUB применён.")
    await cq.answer()

@router.callback_query(F.data.startswith("win:card:"))
async def winner_change_card(cq: CallbackQuery):
    # простая переотправка выбора карт
    deal_id = int(cq.data.split(":",2)[2])
    async with async_session() as s:
        u = await ensure_user(s, cq.from_user)
        d = await s.get(Deal, deal_id)
        prof = await s.scalar(select(TraderProfile).where(TraderProfile.user_id==u.id))
        cards = (await s.execute(select(TraderCard).where(TraderCard.profile_id==prof.id))).scalars().all()
    await cq.message.answer("Выберите новую карту:", reply_markup=cards_kb(cards, deal_id))
    await cq.answer()

7) Подключение роутеров
7.1 app/bot.py — добавь новые роутеры
# app/bot.py
from aiogram import Bot, Dispatcher
from app.handlers.common import router as common_router
from app.handlers.trader import router as trader_router
from app.handlers.admin import router as admin_router
from app.handlers.admin_settings import router as admin_settings_router
from app.handlers.admin_deals import router as admin_deals_router  # покупка (если был)
from app.handlers.admin_deals_sell import router as admin_deals_sell_router
from app.handlers.sell_auction import router as sell_auction_router
from app.handlers.sell_winner import router as sell_winner_router

def create_bot_and_dp(bot_token: str):
    bot = Bot(token=(bot_token or ""), parse_mode="HTML")
    dp = Dispatcher()
    dp.include_router(common_router)
    dp.include_router(admin_router)
    dp.include_router(admin_settings_router)
    try:
        dp.include_router(admin_deals_router)
    except Exception:
        pass
    dp.include_router(admin_deals_sell_router)
    dp.include_router(sell_auction_router)
    dp.include_router(sell_winner_router)
    dp.include_router(trader_router)
    return bot, dp

8) README.md — коротко дополни

Добавь раздел «Продажа USDT»:

Команда /sell (админ) — мастер: сумма в RUB → база % → комиссия сервиса % → аудитория → время → комментарий → предупреждение → публикация.

Этап 1: рассылка только онлайн-трейдерам с USDT-маржой (баланс USDT ≥ требуемого) и с хотя бы одной картой. Принять = +1 REP, Отклонить = −2 REP.

Этап 2/3: торги, допустимый диапазон ставок [−5.00; base_pct], шаг 0.01. Ничья → доп.раунды (до 5), затем случайный выбор.

Победитель: USDT резервируется, трейдер выбирает карту, админ получает реквизиты карты и отмечает «Перевод выполнен». Трейдер подтверждает «Я получил перевод» → USDT списываются из резерва, к RUB-балансу применяется вознаграждение, комиссия сервиса удерживается из положительного вознаграждения.

Отмена победителем: −200 RUB и отмена; тайм-аут оплаты админом: CANCELLED_TIMEOUT без штрафа, резерв возвращается.

9) Acceptance (минимум для теста)

/sell у админа ведёт по шагам и создаёт сделку типа SELL с снэпшотами service_fee_pct, amount_rub, amount_usdt_snapshot.

По публикации — отправляется Этап 1 с кнопками; «Принять/Отклонить» меняют REP и фиксируют участие.

Через ~20 сек стартует Этап 2, участникам приходит запрос ставки; ставки сохраняются; по таймеру выбирается победитель (tie-break до 5 раундов).

Победителю резервируется USDT и предлагается выбрать карту; админам уходит карточка перевода.

Админ «Перевод выполнен» → статус WAITING_TRADER_CONFIRM; трейдер «Я получил перевод» → финализация: списание резерва, применение вознаграждения/комиссии, COMPLETED.

Отмена победителем → −200 RUB, CANCELLED_BY_TRADER и возврат резерва; тайм-аут оплаты → CANCELLED_TIMEOUT и возврат резерва.

---

**Cursor**

Я внесу все необходимые изменения в существующий проект. Начну с проверки текущей структуры и последовательного обновления файлов.


Отлично! `requirements.txt` уже содержит все необходимые зависимости. Теперь обновлю модели данных.


Теперь обновлю модели данных согласно требованиям:


```python
# app/db/models.py
from __future__ import annotations
import enum
from datetime import datetime
from zoneinfo import ZoneInfo
from sqlalchemy import (
    Boolean, DateTime, Enum as SAEnum, ForeignKey, Integer, Numeric, String, Text,
    text, Index, UniqueConstraint
)
from sqlalchemy.orm import DeclarativeBase, Mapped, mapped_column, relationship

TZ = ZoneInfo("Europe/Amsterdam")
def now_tz() -> datetime: return datetime.now(TZ)

class Base(DeclarativeBase): pass

# ---- Роли ----
class RoleEnum(str, enum.Enum):
    admin = "admin"
    trader = "trader"
    operator = "operator"

# ---- Системные настройки (как ранее) ----
class SystemSettings(Base):
    __tablename__ = "system_settings"
    id: Mapped[int] = mapped_column(primary_key=True, autoincrement=True)
    rub_per_usdt: Mapped[float] = mapped_column(Numeric(18, 6), server_default=text("100.00"))
    service_fee_default_pct: Mapped[float] = mapped_column(Numeric(6, 2), server_default=text("1.00"))
    service_fee_min_pct: Mapped[float] = mapped_column(Numeric(6, 2), server_default=text("0.00"))
    service_fee_max_pct: Mapped[float] = mapped_column(Numeric(6, 2), server_default=text("3.00"))
    service_fee_overridable: Mapped[bool] = mapped_column(Boolean, server_default=text("1"))
    round_secs_default: Mapped[int] = mapped_column(Integer, server_default=text("20"))
    max_tie_rounds_default: Mapped[int] = mapped_column(Integer, server_default=text("5"))
    updated_at: Mapped[datetime] = mapped_column(DateTime(timezone=True), default=now_tz, onupdate=now_tz, nullable=False)
    updated_by: Mapped[int | None] = mapped_column(Integer, nullable=True)

# ---- Аудит ----
class AuditLog(Base):
    __tablename__ = "audit_log"
    id: Mapped[int] = mapped_column(primary_key=True, autoincrement=True)
    actor_tg_id: Mapped[int | None] = mapped_column(Integer, nullable=True)
    actor_role: Mapped[str | None] = mapped_column(String(32), nullable=True)
    action: Mapped[str] = mapped_column(String(64))
    entity: Mapped[str] = mapped_column(String(64))
    before: Mapped[str | None] = mapped_column(Text, nullable=True)
    after: Mapped[str | None] = mapped_column(Text, nullable=True)
    created_at: Mapped[datetime] = mapped_column(DateTime(timezone=True), default=now_tz, nullable=False)

# ---- Пользователи ----
class User(Base):
    __tablename__ = "users"
    id: Mapped[int] = mapped_column(primary_key=True, autoincrement=True)
    tg_id: Mapped[int | None] = mapped_column(Integer, unique=True, index=True, nullable=True)
    role: Mapped[RoleEnum] = mapped_column(SAEnum(RoleEnum), default=RoleEnum.trader, nullable=False)
    is_active: Mapped[bool] = mapped_column(Boolean, server_default=text("0"), nullable=False)
    is_online: Mapped[bool] = mapped_column(Boolean, server_default=text("0"), nullable=False)
    rep: Mapped[int] = mapped_column(Integer, server_default=text("0"), nullable=False)
    balance_rub: Mapped[float] = mapped_column(Numeric(18, 2), server_default=text("0.00"), nullable=False)
    balance_usdt: Mapped[float] = mapped_column(Numeric(18, 2), server_default=text("0.00"), nullable=False)
    reserved_usdt: Mapped[float] = mapped_column(Numeric(18, 2), server_default=text("0.00"), nullable=False)
    created_at: Mapped[datetime] = mapped_column(DateTime(timezone=True), default=now_tz, nullable=False)

# ---- Профиль трейдера / карты (как ранее) ----
class TraderProfile(Base):
    __tablename__ = "trader_profiles"
    id: Mapped[int] = mapped_column(primary_key=True, autoincrement=True)
    external_id: Mapped[str] = mapped_column(String(64), unique=True, index=True)
    nickname: Mapped[str] = mapped_column(String(64))
    full_name: Mapped[str] = mapped_column(String(128))
    phone: Mapped[str] = mapped_column(String(32))
    referral_code: Mapped[str | None] = mapped_column(String(64), nullable=True)
    user_id: Mapped[int | None] = mapped_column(ForeignKey("users.id"), nullable=True)
    created_at: Mapped[datetime] = mapped_column(DateTime(timezone=True), default=now_tz, nullable=False)
    user: Mapped["User"] = relationship()
    cards: Mapped[list["TraderCard"]] = relationship(back_populates="profile", cascade="all, delete-orphan")

class BankEnum(str, enum.Enum):
    TBANK = "ТБАНК"
    ALFABANK = "АЛЬФАБАНК"
    SBERBANK = "СБЕРБАНК"
    VTB = "ВТБ"
    YANDEX = "ЯНДЕКС БАНК"
    OZON = "ОЗОН БАНК"
    OTHER = "ДРУГОЙ БАНК"

class TraderCard(Base):
    __tablename__ = "trader_cards"
    id: Mapped[int] = mapped_column(primary_key=True, autoincrement=True)
    profile_id: Mapped[int] = mapped_column(ForeignKey("trader_profiles.id"), index=True)
    bank: Mapped[BankEnum] = mapped_column(SAEnum(BankEnum), default=BankEnum.TBANK)
    bank_other_name: Mapped[str | None] = mapped_column(String(64), nullable=True)
    card_number: Mapped[str] = mapped_column(String(32))  # хранить в маскируемом виде на UI
    holder_name: Mapped[str] = mapped_column(String(128))
    has_sbp: Mapped[bool] = mapped_column(Boolean, server_default=text("0"), nullable=False)
    sbp_number: Mapped[str | None] = mapped_column(String(64), nullable=True)
    sbp_fullname: Mapped[str | None] = mapped_column(String(128), nullable=True)
    created_at: Mapped[datetime] = mapped_column(DateTime(timezone=True), default=now_tz, nullable=False)
    profile: Mapped["TraderProfile"] = relationship(back_populates="cards")

# ---- Токены доступа ----
class AccessToken(Base):
    __tablename__ = "access_tokens"
    id: Mapped[int] = mapped_column(primary_key=True, autoincrement=True)
    profile_id: Mapped[int] = mapped_column(ForeignKey("trader_profiles.id"), index=True)
    token: Mapped[str] = mapped_column(String(24), unique=True, index=True)
    created_at: Mapped[datetime] = mapped_column(DateTime(timezone=True), default=now_tz, nullable=False)
    consumed_at: Mapped[datetime | None] = mapped_column(DateTime(timezone=True), nullable=True)

# ---- Сделки / Аукцион ----
class DealType(str, enum.Enum):
    BUY = "BUY"     # админ покупает RUB (старый сценарий)
    SELL = "SELL"   # ПРОДАЖА USDT с карты трейдера (этот сценарий)

class DealStatus(str, enum.Enum):
    DRAFT = "DRAFT"
    OPEN = "OPEN"                    # Этап 1 рассылается
    BIDDING = "BIDDING"              # Этап 2/3 идут
    WINNER_ASSIGNED = "WINNER_ASSIGNED"
    WAITING_ADMIN_TRANSFER = "WAITING_ADMIN_TRANSFER"   # админ должен отправить RUB на карту
    WAITING_TRADER_CONFIRM = "WAITING_TRADER_CONFIRM"   # админ подтвердил, ждём подтверждение трейдера
    COMPLETED = "COMPLETED"
    CANCELLED = "CANCELLED"
    CANCELLED_BY_TRADER = "CANCELLED_BY_TRADER"
    CANCELLED_TIMEOUT = "CANCELLED_TIMEOUT"
    REVIEW = "REVIEW"

class Deal(Base):
    __tablename__ = "deals"
    id: Mapped[int] = mapped_column(primary_key=True, autoincrement=True)
    deal_no: Mapped[str] = mapped_column(String(32), unique=True, index=True)
    deal_type: Mapped[DealType] = mapped_column(SAEnum(DealType), default=DealType.SELL, index=True)

    amount_rub: Mapped[float] = mapped_column(Numeric(18, 2))
    amount_usdt_snapshot: Mapped[float] = mapped_column(Numeric(18, 2))

    base_pct: Mapped[float] = mapped_column(Numeric(6, 2))           # верхняя граница ставок
    service_fee_pct: Mapped[float] = mapped_column(Numeric(6, 2))    # снэпшот комиссии сервиса

    # Выбранная победителем карта (снэпшоты)
    winner_card_id: Mapped[int | None] = mapped_column(ForeignKey("trader_cards.id"), nullable=True)
    winner_card_bank: Mapped[str | None] = mapped_column(String(64), nullable=True)
    winner_card_mask: Mapped[str | None] = mapped_column(String(32), nullable=True)
    winner_card_holder: Mapped[str | None] = mapped_column(String(128), nullable=True)

    audience_type: Mapped[str] = mapped_column(String(32))  # all / rep_range / personal
    audience_filter: Mapped[str | None] = mapped_column(String(256), nullable=True)  # JSON

    comment: Mapped[str | None] = mapped_column(String(1000), nullable=True)
    warning_enabled: Mapped[bool] = mapped_column(Boolean, server_default=text("0"))

    round_secs: Mapped[int] = mapped_column(Integer, server_default=text("20"))
    max_tie_rounds: Mapped[int] = mapped_column(Integer, server_default=text("5"))

    pay_deadline_at: Mapped[datetime | None] = mapped_column(DateTime(timezone=True), nullable=True)

    status: Mapped[DealStatus] = mapped_column(SAEnum(DealStatus), index=True, default=DealStatus.DRAFT)
    winner_user_id: Mapped[int | None] = mapped_column(ForeignKey("users.id"), nullable=True)
    winner_bid_pct: Mapped[float | None] = mapped_column(Numeric(6, 2), nullable=True)

    created_at: Mapped[datetime] = mapped_column(DateTime(timezone=True), default=now_tz, nullable=False)

Index("ix_deals_type_status", Deal.deal_type, Deal.status)

# Участники/ставки/раунды
class DealParticipant(Base):
    __tablename__ = "deal_participants"
    id: Mapped[int] = mapped_column(primary_key=True, autoincrement=True)
    deal_id: Mapped[int] = mapped_column(ForeignKey("deals.id"), index=True)
    user_id: Mapped[int] = mapped_column(ForeignKey("users.id"), index=True)
    accepted: Mapped[bool] = mapped_column(Boolean, server_default=text("0"))
    created_at: Mapped[datetime] = mapped_column(DateTime(timezone=True), default=now_tz, nullable=False)
    UniqueConstraint("deal_id", "user_id", name="uq_participant")

class DealRound(Base):
    __tablename__ = "deal_rounds"
    id: Mapped[int] = mapped_column(primary_key=True, autoincrement=True)
    deal_id: Mapped[int] = mapped_column(ForeignKey("deals.id"), index=True)
    round_number: Mapped[int] = mapped_column(Integer, index=True)  # 1=Этап2, 2..=тай-брейки
    started_at: Mapped[datetime] = mapped_column(DateTime(timezone=True), default=now_tz, nullable=False)
    deadline_at: Mapped[datetime] = mapped_column(DateTime(timezone=True), nullable=False)

class Bid(Base):
    __tablename__ = "bids"
    id: Mapped[int] = mapped_column(primary_key=True, autoincrement=True)
    deal_id: Mapped[int] = mapped_column(ForeignKey("deals.id"), index=True)
    user_id: Mapped[int] = mapped_column(ForeignKey("users.id"), index=True)
    round_number: Mapped[int] = mapped_column(Integer, index=True)
    pct: Mapped[float] = mapped_column(Numeric(6, 2))
    created_at: Mapped[datetime] = mapped_column(DateTime(timezone=True), default=now_tz, nullable=False)

Index("ix_bids_deal_round_user", Bid.deal_id, Bid.round_number, Bid.user_id, unique=True)
Index("ix_bids_deal_round_pct", Bid.deal_id, Bid.round_number, Bid.pct)
```

Теперь обновлю файл `app/utils/money.py`:


Отлично! Файл уже содержит нужную функцию. Теперь создам новый файл `app/services/balance.py`:


```python
# app/services/balance.py
from __future__ import annotations
from sqlalchemy import select, update
from app.db.base import async_session
from app.db.models import User

async def ensure_usdt_margin(user_id: int, need_usdt: float) -> bool:
    async with async_session() as s:
        u = await s.get(User, user_id)
        return float(u.balance_usdt) >= need_usdt

async def reserve_usdt(user_id: int, amount: float) -> bool:
    """Перенос amount из balance_usdt в reserved_usdt. Возвращает True, если успешно."""
    async with async_session() as s:
        u = await s.get(User, user_id)
        if float(u.balance_usdt) < amount: return False
        u.balance_usdt = float(u.balance_usdt) - amount
        u.reserved_usdt = float(u.reserved_usdt) + amount
        await s.commit()
        return True

async def release_usdt(user_id: int, amount: float) -> None:
    """Возврат резерва в баланс."""
    async with async_session() as s:
        u = await s.get(User, user_id)
        u.reserved_usdt = max(0.0, float(u.reserved_usdt) - amount)
        u.balance_usdt = float(u.balance_usdt) + amount
        await s.commit()

async def consume_reserved_usdt(user_id: int, amount: float) -> bool:
    """Окончательное списание из резерва (не возвращаем на баланс)."""
    async with async_session() as s:
        u = await s.get(User, user_id)
        if float(u.reserved_usdt) < amount: return False
        u.reserved_usdt = float(u.reserved_usdt) - amount
        await s.commit()
        return True
```

Теперь проверю и обновлю файл `app/utils/validation.py`:


Добавлю функцию маскирования карты:


```python
from email_validator import validate_email, EmailNotValidError

def mask_card(card_number: str) -> str:
    digits = "".join(ch for ch in card_number if ch.isdigit())
    tail = digits[-4:] if len(digits) >= 4 else digits
    return f"**** **** **** {tail}" if tail else "****"

def validate_pay_account(s: str) -> bool:
    s = s.strip()
    if not (6 <= len(s) <= 64): return False
    # цифры, +, пробелы, и произвольный хвост банка (проверим длину отдельно в мастере)
    ok = all(ch.isdigit() or ch in "+ " or ch.isalpha() for ch in s)
    return ok

def validate_email_addr(addr: str) -> bool:
    try:
        validate_email(addr, allow_smtputf8=False, allow_empty_local=False)
        return True
    except EmailNotValidError:
        return False

def validate_decimal_range_step(value: float, lo: float, hi: float, step: float = 0.01) -> bool:
    if not (lo <= value <= hi): return False
    # проверка шага 0.01
    return abs(round(value * 100) - value * 100) < 1e-9
```

Теперь обновлю файл `app/scheduler.py`:


Теперь дополню файл `app/scheduler.py` новыми функциями:


```python
from datetime import datetime
from typing import Optional
from zoneinfo import ZoneInfo

from apscheduler.schedulers.asyncio import AsyncIOScheduler
from apscheduler.jobstores.sqlalchemy import SQLAlchemyJobStore
from sqlalchemy import select, update

from app.config import settings
from app.db.base import get_async_session
from app.db.models import Deal, DealStatus
from app.logging_setup import get_logger

logger = get_logger(__name__)


class AuctionScheduler:
    """Планировщик задач для аукциона."""
    
    def __init__(self):
        self.scheduler: Optional[AsyncIOScheduler] = None
    
    def init_scheduler(self) -> None:
        """Инициализация планировщика."""
        # Создаем хранилище задач в SQLite
        jobstore = SQLAlchemyJobStore(
            url=settings.scheduler_db_url,
            tablename='apscheduler_jobs'
        )
        
        # Создаем планировщик
        self.scheduler = AsyncIOScheduler(
            timezone="Europe/Amsterdam",
            jobstores={'default': jobstore}
        )
        
        logger.info("Планировщик инициализирован")
    
    def start_scheduler(self) -> None:
        """Запуск планировщика."""
        if self.scheduler is None:
            raise RuntimeError("Планировщик не инициализирован")
        
        # Регистрируем задачи
        self._register_jobs()
        
        # Запускаем планировщик
        self.scheduler.start()
        logger.info("Планировщик запущен")
    
    def stop_scheduler(self) -> None:
        """Остановка планировщика."""
        if self.scheduler is not None:
            self.scheduler.shutdown()
            logger.info("Планировщик остановлен")
    
    def _register_jobs(self) -> None:
        """Регистрация задач в планировщике."""
        if self.scheduler is None:
            return
        
        # Heartbeat каждую минуту
        self.scheduler.add_job(
            heartbeat,
            'interval',
            minutes=1,
            id='heartbeat',
            replace_existing=True,
            max_instances=1
        )
        
        # Закрытие просроченных сделок каждую минуту
        self.scheduler.add_job(
            close_expired_deals,
            'interval',
            minutes=1,
            id='close_expired_deals',
            replace_existing=True,
            max_instances=1
        )
        
        logger.info("Задачи зарегистрированы в планировщике")


async def heartbeat() -> None:
    """Задача heartbeat для проверки работы планировщика."""
    logger.info("💓 Heartbeat от планировщика")


async def close_expired_deals() -> None:
    """Закрытие просроченных сделок."""
    try:
        now = datetime.now(ZoneInfo("Europe/Amsterdam"))
        closed_count = 0
        
        async for session in get_async_session():
            # Находим просроченные открытые сделки по pay_deadline_at
            result = await session.execute(
                select(Deal).where(
                    Deal.status == DealStatus.OPEN,
                    Deal.pay_deadline_at <= now
                )
            )
            expired_deals = result.scalars().all()
            
            if expired_deals:
                # Закрываем сделки атомарно
                await session.execute(
                    update(Deal)
                    .where(
                        Deal.status == DealStatus.OPEN,
                        Deal.pay_deadline_at <= now
                    )
                    .values(status=DealStatus.EXPIRED_PENALTY)
                )
                
                await session.commit()
                closed_count = len(expired_deals)
                
                logger.info(f"Закрыто {closed_count} просроченных сделок")
            else:
                logger.debug("Просроченных сделок не найдено")
            break
        
        if closed_count > 0:
            logger.info(f"✅ Задача закрытия сделок выполнена: закрыто {closed_count} сделок")
        
    except Exception as e:
        logger.error(f"Ошибка при закрытии просроченных сделок: {e}")


# Глобальный экземпляр планировщика
scheduler = AuctionScheduler()

# ---- Новые функции для постановки задач аукциона ----
async def schedule_stage1_end(deal_id: int, after_seconds: int):
    get_scheduler().add_job("app.workers.auction:end_stage1", "date",
                            run_date=datetime.now(ZoneInfo("Europe/Amsterdam"))+timedelta(seconds=after_seconds),
                            args=[deal_id], id=f"deal:{deal_id}:stage1", replace_existing=True)

async def schedule_round_end(deal_id: int, round_number: int, after_seconds: int):
    get_scheduler().add_job("app.workers.auction:end_round", "date",
                            run_date=datetime.now(ZoneInfo("Europe/Amsterdam"))+timedelta(seconds=after_seconds),
                            args=[deal_id, round_number], id=f"deal:{deal_id}:round:{round_number}",
                            replace_existing=True)

async def schedule_pay_timeout(deal_id: int, after_minutes: int):
    get_scheduler().add_job("app.workers.auction:pay_timeout", "date",
                            run_date=datetime.now(ZoneInfo("Europe/Amsterdam"))+timedelta(minutes=after_minutes),
                            args=[deal_id], id=f"deal:{deal_id}:pay", replace_existing=True)

async def schedule_trader_confirm_window(deal_id: int, after_minutes: int = 10):
    get_scheduler().add_job("app.workers.auction:trader_confirm_timeout", "date",
                            run_date=datetime.now(ZoneInfo("Europe/Amsterdam"))+timedelta(minutes=after_minutes),
                            args=[deal_id], id=f"deal:{deal_id}:confirm", replace_existing=True)

def get_scheduler() -> AsyncIOScheduler:
    return scheduler.scheduler
```

Теперь создам новый файл `app/workers/auction.py`:


```python
# app/workers/auction.py
from __future__ import annotations
from datetime import datetime, timedelta
from zoneinfo import ZoneInfo
from sqlalchemy import select, func, update, and_, asc
from aiogram import Bot

from app.config import settings
from app.db.base import async_session
from app.db.models import (Deal, DealStatus, DealRound, DealParticipant, Bid, User, TraderCard)
from app.services.balance import reserve_usdt, release_usdt, consume_reserved_usdt
from app.utils.money import bank_round_2
from app.logging_setup import get_logger

logger = get_logger(__name__)
TZ = ZoneInfo("Europe/Amsterdam")

async def _get_bot() -> Bot:
    from app.bot import create_bot_and_dp
    bot, _ = create_bot_and_dp(settings.bot_token)
    return bot

# ---- Завершение Этапа 1: формируем список допущенных и запускаем торги (раунд 1) ----
async def end_stage1(deal_id: int):
    async with async_session() as s:
        deal = await s.get(Deal, deal_id)
        if not deal or deal.status != DealStatus.OPEN:
            return
        deal.status = DealStatus.BIDDING
        # старт раунда 1
        round_secs = int(deal.round_secs or 20)
        dr = DealRound(deal_id=deal.id, round_number=1,
                       started_at=datetime.now(TZ),
                       deadline_at=datetime.now(TZ) + timedelta(seconds=round_secs))
        s.add(dr)
        await s.commit()
    # Запланируем завершение раунда
    from app.scheduler import schedule_round_end
    await schedule_round_end(deal_id, 1, round_secs)
    
    # Уведомляем участников о начале торгов
    from app.handlers.sell_auction import notify_round_start
    await notify_round_start(deal_id, 1)

# ---- Завершение любого раунда: определяем минимум, ничьи -> новый раунд/иначе победитель ----
async def end_round(deal_id: int, round_number: int):
    async with async_session() as s:
        deal = await s.get(Deal, deal_id)
        if not deal or deal.status != DealStatus.BIDDING:
            return
        # найти минимальную ставку на этом раунде
        res = await s.execute(select(Bid.pct).where(Bid.deal_id==deal_id, Bid.round_number==round_number).order_by(asc(Bid.pct)))
        rows = [float(r[0]) for r in res.all()]
        if not rows:
            # никто не сделал ставку — отменяем без штрафов
            deal.status = DealStatus.CANCELLED
            await s.commit()
            return
        min_pct = rows[0]
        # кто поставил минимум?
        res2 = await s.execute(select(Bid.user_id).where(Bid.deal_id==deal_id, Bid.round_number==round_number, Bid.pct==min_pct))
        users = [int(r[0]) for r in res2.all()]
        if len(users) > 1:
            # ничья
            if round_number >= int(deal.max_tie_rounds or 5):
                # случайный победитель из ничьей
                import random
                winner_id = random.choice(users)
                deal.winner_user_id = winner_id
                deal.winner_bid_pct = min_pct
                deal.status = DealStatus.WINNER_ASSIGNED
                await s.commit()
                await _after_winner_assigned(s, deal)
                return
            # иначе новый раунд только среди этих пользователей
            next_round = round_number + 1
            dr = DealRound(deal_id=deal.id, round_number=next_round,
                           started_at=datetime.now(TZ),
                           deadline_at=datetime.now(TZ) + timedelta(seconds=int(deal.round_secs or 20)))
            s.add(dr)
            await s.commit()
            from app.scheduler import schedule_round_end
            await schedule_round_end(deal_id, next_round, int(deal.round_secs or 20))
            
            # Уведомляем участников о новом раунде
            from app.handlers.sell_auction import notify_round_start
            await notify_round_start(deal_id, next_round)
            return
        # один победитель
        winner_id = users[0]
        deal.winner_user_id = winner_id
        deal.winner_bid_pct = min_pct
        deal.status = DealStatus.WINNER_ASSIGNED
        await s.commit()
    await _after_winner_assigned(None, deal_id=deal_id)

async def _after_winner_assigned(s_in: any = None, deal_id: int | None = None, deal: Deal | None = None):
    # Резерв USDT, запрос выбрать карту, старт таймера для админа
    if not deal:
        async with async_session() as s:
            deal = await s.get(Deal, deal_id)
    if not deal: return
    from app.scheduler import schedule_pay_timeout
    # резерв USDT у победителя
    ok = await reserve_usdt(int(deal.winner_user_id), float(deal.amount_usdt_snapshot))
    if not ok:
        # не смогли зарезервировать (параллельная трата) -> отмена
        async with async_session() as s:
            d = await s.get(Deal, deal.id)
            d.status = DealStatus.CANCELLED
            await s.commit()
        return
    # попросим победителя выбрать карту
    bot = await _get_bot()
    await bot.send_message(int(await _winner_tg_id(deal.winner_user_id)),
        f"<b>Вы выиграли аукцион — ПРОДАЖА USDT</b>\n"
        f"Сделка № <code>{deal.deal_no}</code>\n"
        f"Сумма: {float(deal.amount_rub):.2f} RUB (~{float(deal.amount_usdt_snapshot):.2f} USDT)\n"
        f"Ваша ставка: {float(deal.winner_bid_pct):.2f}%\n\n"
        f"Выберите карту, на которую придут RUB: /pick_card {deal.id}")
    # старт общего таймера оплаты для админа
    await schedule_pay_timeout(deal.id, after_minutes=_minutes_from_deadline(deal))

def _minutes_from_deadline(deal: Deal) -> int:
    # в модели мы не храним «минуты» отдельно; можно вычислить по настройке/состоянию
    return 20  # безопасное дефолтное значение; реальное время задаётся при создании сделки (см. handler)

async def pay_timeout(deal_id: int):
    # админ не успел отправить — отмена без штрафа, резервы вернуть
    async with async_session() as s:
        d = await s.get(Deal, deal_id)
        if not d or d.status not in (DealStatus.WINNER_ASSIGNED, DealStatus.WAITING_ADMIN_TRANSFER):
            return
        if d.winner_user_id:
            await release_usdt(int(d.winner_user_id), float(d.amount_usdt_snapshot))
        d.status = DealStatus.CANCELLED_TIMEOUT
        await s.commit()

async def trader_confirm_timeout(deal_id: int):
    # окно подтверждения трейдером истекло — оператор решает вручную; оставим REVIEW
    async with async_session() as s:
        d = await s.get(Deal, deal_id)
        if not d or d.status != DealStatus.WAITING_TRADER_CONFIRM:
            return
        d.status = DealStatus.REVIEW
        await s.commit()

async def _winner_tg_id(user_id: int) -> int:
    async with async_session() as s:
        u = await s.get(User, user_id)
        return int(u.tg_id or 0)
```

Теперь создам файл `app/handlers/admin_deals_sell.py`:


```python
# app/handlers/admin_deals_sell.py
from __future__ import annotations
from aiogram import Router, F
from aiogram.filters import Command
from aiogram.fsm.state import State, StatesGroup
from aiogram.fsm.context import FSMContext
from aiogram.types import Message, CallbackQuery
from aiogram.utils.keyboard import InlineKeyboardBuilder
from sqlalchemy import select
from datetime import datetime, timedelta
from zoneinfo import ZoneInfo
import json

from app.config import settings
from app.db.base import async_session
from app.db.models import RoleEnum, User, Deal, DealType, DealStatus
from app.handlers.utils import ensure_user
from app.services.settings import get_settings
from app.utils.money import bank_round_2
from app.utils.validation import validate_decimal_range_step
from app.scheduler import schedule_stage1_end

router = Router(name="admin_deals_sell")
TZ = ZoneInfo("Europe/Amsterdam")

class SellStates(StatesGroup):
    amount_rub = State()
    base_pct = State()
    service_fee = State()
    audience = State()
    audience_params = State()
    pay_time = State()
    comment_ask = State()
    comment_text = State()
    warning_toggle = State()
    confirm = State()

def kb_yesno(cb_yes: str, cb_no: str):
    b = InlineKeyboardBuilder()
    b.button(text="Да", callback_data=cb_yes)
    b.button(text="Нет", callback_data=cb_no)
    b.adjust(2); return b.as_markup()

def kb_audience():
    b = InlineKeyboardBuilder()
    b.button(text="Для всех (онлайн + USDT маржа + карта)", callback_data="aud:all")
    b.button(text="По рейтингу", callback_data="aud:rep")
    b.button(text="Персонально", callback_data="aud:per")
    b.adjust(1)
    return b.as_markup()

@router.message(Command("sell"))
async def sell_menu(message: Message, state: FSMContext):
    async with async_session() as s:
        u = await ensure_user(s, message.from_user)
        if u.role != RoleEnum.admin:
            await message.answer("Доступно только администратору.")
            return
    await state.clear()
    await state.set_state(SellStates.amount_rub)
    await message.answer("1) Введите сумму сделки в RUB:")

@router.message(SellStates.amount_rub)
async def step_amount(message: Message, state: FSMContext):
    try:
        rub = float((message.text or "").replace(" ", "").replace(",", "."))
        if rub <= 0: raise ValueError
        s = await get_settings()
        usdt = bank_round_2(rub / float(s.rub_per_usdt))
        await state.update_data(amount_rub=bank_round_2(rub), amount_usdt=usdt)
        await state.set_state(SellStates.base_pct)
        await message.answer(f"USDT эквивалент: ~ {usdt:.2f}\n2) Вознаграждение трейдера, % (−5.00..+25.00):")
    except Exception:
        await message.answer("Некорректная сумма. Повторите ввод.")

@router.message(SellStates.base_pct)
async def step_base_pct(message: Message, state: FSMContext):
    try:
        v = float((message.text or "").replace(",", "."))
        if not validate_decimal_range_step(v, -5.00, 25.00, 0.01): raise ValueError
        await state.update_data(base_pct=round(v,2))
        s = await get_settings()
        if s.service_fee_overridable:
            await state.set_state(SellStates.service_fee)
            await message.answer(f"3) Комиссия сервиса, % (диапазон {s.service_fee_min_pct:.2f}..{s.service_fee_max_pct:.2f}), шаг 0.01.\nПо умолчанию {s.service_fee_default_pct:.2f}%")
        else:
            await state.update_data(service_fee_pct=float(s.service_fee_default_pct))
            await state.set_state(SellStates.audience)
            await message.answer("4) Выберите аудиторию:", reply_markup=kb_audience())
    except Exception:
        await message.answer("Неверное значение. Введите в диапазоне −5.00..+25.00 с шагом 0.01.")

@router.message(SellStates.service_fee)
async def step_service_fee(message: Message, state: FSMContext):
    from app.services.settings import get_settings
    s = await get_settings()
    try:
        v = float((message.text or "").replace(",", "."))
        if not validate_decimal_range_step(v, float(s.service_fee_min_pct), float(s.service_fee_max_pct), 0.01): raise ValueError
        await state.update_data(service_fee_pct=round(v,2))
        await state.set_state(SellStates.audience)
        await message.answer("4) Выберите аудиторию:", reply_markup=kb_audience())
    except Exception:
        await message.answer(f"Неверно. Введите значение в диапазоне {float(s.service_fee_min_pct):.2f}..{float(s.service_fee_max_pct):.2f} с шагом 0.01.")

@router.callback_query(SellStates.audience, F.data.startswith("aud:"))
async def step_audience(cq: CallbackQuery, state: FSMContext):
    mode = cq.data.split(":",1)[1]
    await state.update_data(audience_type=mode)
    if mode == "rep":
        await state.set_state(SellStates.audience_params)
        await cq.message.answer("Укажите REP диапазон: 'от до' (можно оставить пустым один конец). Пример: '10 100' или '10' или ' 100'")
    elif mode == "per":
        await state.set_state(SellStates.audience_params)
        await cq.message.answer("Укажите telegram_id трейдера:")
    else:
        await state.set_state(SellStates.pay_time)
        await cq.message.answer("5) Время на сделку (мин): 5/10/15/20/25/30")
    await cq.answer()

@router.message(SellStates.audience_params)
async def step_audience_params(message: Message, state: FSMContext):
    data = (message.text or "").strip()
    aud = (await state.get_data())["audience_type"]
    filt = {}
    if aud == "rep":
        parts = data.split()
        if len(parts) == 2:
            filt = {"rep_min": int(parts[0]), "rep_max": int(parts[1])}
        elif len(parts) == 1:
            try:
                v = int(parts[0]); filt = {"rep_min": v}
            except: filt = {"rep_max": int(parts[0])}
        else:
            filt = {}
    elif aud == "per":
        try:
            filt = {"telegram_id": int(data)}
        except:
            await message.answer("Неверный telegram_id.")
            return
    await state.update_data(audience_filter=filt)
    await state.set_state(SellStates.pay_time)
    await message.answer("5) Время на сделку (мин): 5/10/15/20/25/30")

@router.message(SellStates.pay_time)
async def step_pay_time(message: Message, state: FSMContext):
    try:
        mins = int((message.text or "").strip())
        if mins not in (5,10,15,20,25,30): raise ValueError
        await state.update_data(pay_mins=mins)
        await state.set_state(SellStates.comment_ask)
        await message.answer("6) Комментарий к сделке? (Да/Нет)", reply_markup=InlineKeyboardBuilder().row(
            InlineKeyboardBuilder().button(text="Да", callback_data="cmt:yes").button(text="Нет", callback_data="cmt:no").as_markup().inline_keyboard[0]
        ))
    except Exception:
        await message.answer("Введите одно из значений: 5/10/15/20/25/30.")

@router.callback_query(SellStates.comment_ask, F.data.startswith("cmt:"))
async def step_comment_ask(cq: CallbackQuery, state: FSMContext):
    yn = cq.data.split(":",1)[1]
    if yn == "yes":
        await state.set_state(SellStates.comment_text)
        await cq.message.answer("Введите комментарий (до 1000 символов).")
    else:
        await state.update_data(comment=None)
        await state.set_state(SellStates.warning_toggle)
        await cq.message.answer("7) Добавить предупреждение? (Да/Нет)", reply_markup=InlineKeyboardBuilder().row(
            InlineKeyboardBuilder().button(text="Да", callback_data="warn:yes").button(text="Нет", callback_data="warn:no").as_markup().inline_keyboard[0]
        ))
    await cq.answer()

@router.message(SellStates.comment_text)
async def step_comment_text(message: Message, state: FSMContext):
    txt = (message.text or "").strip()
    if len(txt) > 1000:
        await message.answer("Слишком длинно. До 1000 символов.")
        return
    await state.update_data(comment=txt)
    await state.set_state(SellStates.warning_toggle)
    await message.answer("7) Добавить предупреждение? (Да/Нет)", reply_markup=InlineKeyboardBuilder().row(
        InlineKeyboardBuilder().button(text="Да", callback_data="warn:yes").button(text="Нет", callback_data="warn:no").as_markup().inline_keyboard[0]
    ))

@router.callback_query(SellStates.warning_toggle, F.data.startswith("warn:"))
async def step_warning(cq: CallbackQuery, state: FSMContext):
    yn = cq.data.split(":",1)[1]
    await state.update_data(warning_enabled=(yn=="yes"))
    data = await state.get_data()
    # подтверждение
    await state.set_state(SellStates.confirm)
    s = await get_settings()
    usdt = data["amount_usdt"]; rub = data["amount_rub"]
    txt = (
        "<b>Подтверждение сделки — ПРОДАЖА USDT</b>\n"
        f"Сумма: {rub:.2f} RUB (~{usdt:.2f} USDT)\n"
        f"Вознаграждение (база): {data['base_pct']:.2f}%\n"
        f"Комиссия сервиса: {data.get('service_fee_pct', float(s.service_fee_default_pct)):.2f}%\n"
        f"Аудитория: {data.get('audience_type')}\n"
        f"Комментарий: {data.get('comment') or '-'}\n"
        f"Предупреждение: {'вкл' if data.get('warning_enabled') else 'выкл'}\n"
        f"Время на сделку: {data['pay_mins']} мин"
    )
    b = InlineKeyboardBuilder()
    b.button(text="Опубликовать", callback_data="sell:publish")
    b.button(text="Отмена", callback_data="sell:cancel")
    b.adjust(2)
    await cq.message.answer(txt, reply_markup=b.as_markup())
    await cq.answer()

@router.callback_query(SellStates.confirm, F.data.startswith("sell:"))
async def publish_sell(cq: CallbackQuery, state: FSMContext):
    act = cq.data.split(":",1)[1]
    if act == "cancel":
        await state.clear()
        await cq.message.answer("Отменено.")
        await cq.answer(); return
    data = await state.get_data()
    s = await get_settings()

    # номер сделки
    deal_no = datetime.now(TZ).strftime("%Y%m%d-") + __import__("secrets").token_hex(4).upper()[:7]
    service_fee_pct = float(data.get("service_fee_pct", float(s.service_fee_default_pct)))

    async with async_session() as ss:
        u = await ensure_user(ss, cq.from_user)
        if u.role != RoleEnum.admin:
            await cq.answer("Только для администратора", show_alert=True); return

        deal = Deal(
            deal_no=deal_no,
            deal_type=DealType.SELL,
            amount_rub=float(data["amount_rub"]),
            amount_usdt_snapshot=float(data["amount_usdt"]),
            base_pct=float(data["base_pct"]),
            service_fee_pct=service_fee_pct,
            audience_type=data["audience_type"],
            audience_filter=json.dumps(data.get("audience_filter") or {}),
            comment=data.get("comment"),
            warning_enabled=bool(data.get("warning_enabled", False)),
            round_secs=int(s.round_secs_default),
            max_tie_rounds=int(s.max_tie_rounds_default),
            status=DealStatus.OPEN,
        )
        ss.add(deal)
        await ss.commit()

    await state.clear()
    await cq.message.answer(f"Сделка опубликована: ПРОДАЖА USDT\n№ <code>{deal_no}</code>\n"
                            f"{data['amount_rub']:.2f} RUB (~{data['amount_usdt']:.2f} USDT)\n"
                            f"База: {data['base_pct']:.2f}% • Комиссия сервиса: {service_fee_pct:.2f}%\n"
                            f"Время на сделку: {data['pay_mins']} мин")

    # Рассылка Этапа 1 + постановка завершения Этапа 1
    from app.handlers.sell_auction import broadcast_stage1
    await broadcast_stage1(int(deal.id))
    await schedule_stage1_end(int(deal.id), after_seconds=int(s.round_secs_default))
    await cq.answer()
```

Теперь создам файл `app/handlers/sell_auction.py`:


```python
# app/handlers/sell_auction.py
from __future__ import annotations
from aiogram import Router, F
from aiogram.types import Message, CallbackQuery
from aiogram.filters import Command
from aiogram.fsm.state import State, StatesGroup
from aiogram.fsm.context import FSMContext
from aiogram.utils.keyboard import InlineKeyboardBuilder
from sqlalchemy import select, and_
from datetime import datetime
from zoneinfo import ZoneInfo
import json

from app.db.base import async_session
from app.db.models import (Deal, DealType, DealStatus, DealParticipant, User, Bid, DealRound)
from app.services.settings import get_settings
from app.services.balance import ensure_usdt_margin
from app.handlers.utils import ensure_user
from app.utils.money import bank_round_2

router = Router(name="sell_auction")
TZ = ZoneInfo("Europe/Amsterdam")

class BidStates(StatesGroup):
    waiting_bid = State()  # пользователь вводит ставку для конкретной сделки

# ===== Этап 1: Рассылка =====
async def eligible_traders(deal: Deal) -> list[int]:
    async with async_session() as s:
        q = select(User.tg_id, User.id, User.is_online, User.balance_usdt).where(
            User.role=="trader", User.is_active==True, User.is_online==True
        )
        rows = (await s.execute(q)).all()
        # фильтры аудитории
        filt = json.loads(deal.audience_filter or "{}")
        out = []
        for tg_id, uid, online, busdt in rows:
            if not online: continue
            if float(busdt) < float(deal.amount_usdt_snapshot): continue
            # карта: допустим наличие карты проверим позже при выборе (или здесь — опционально)
            # репутация
            if deal.audience_type == "rep":
                rep_q = await s.execute(select(User.rep).where(User.id==uid))
                rep = int(rep_q.scalar() or 0)
                if "rep_min" in filt and rep < int(filt["rep_min"]): continue
                if "rep_max" in filt and rep > int(filt["rep_max"]): continue
            if deal.audience_type == "personal":
                if int(filt.get("telegram_id", 0)) != int(tg_id): continue
            out.append(int(tg_id))
        return out

def stage1_kb(deal_id: int):
    b = InlineKeyboardBuilder()
    b.button(text="Принять сделку (+1 REP)", callback_data=f"sell1:accept:{deal_id}")
    b.button(text="Отклонить сделку (-2 REP)", callback_data=f"sell1:decline:{deal_id}")
    b.button(text="⏳ ТАЙМЕР", callback_data="noop")
    b.adjust(1,1,1)
    return b.as_markup()

async def broadcast_stage1(deal_id: int):
    from app.bot import create_bot_and_dp
    from app.utils.money import bank_round_2
    bot, _ = create_bot_and_dp("")
    async with async_session() as s:
        d = await s.get(Deal, deal_id)
        sset = await get_settings()
        # готовим текст
        max_reward = 0.0
        if float(d.base_pct) > 0:
            max_reward = bank_round_2(float(d.amount_rub) * float(d.base_pct)/100.0)
        txt = (
            "<b>ВЫ УЧАСТВУЕТЕ В АУКЦИОНЕ!</b>\n"
            "Вид сделки: <b>ПРОДАЖА USDT</b>\n"
            f"Номер: <code>{d.deal_no}</code>\n"
            f"Вознаграждение (база): {float(d.base_pct):.2f}%\n"
            f"Сумма: {float(d.amount_rub):.2f} RUB (~{float(d.amount_usdt_snapshot):.2f} USDT)\n"
            f"Макс. вознаграждение (RUB): {max_reward:.2f}\n"
            f"Комиссия сервиса: {float(d.service_fee_pct):.2f}%\n"
            f"Время сделки: {int(sset.round_secs_default)} сек для Этапа 1; оплата: {int( (d.pay_deadline_at is not None) or 0)}\n"
            + (f"\n<b>Комментарий:</b>\n{d.comment}\n" if d.comment else "") +
            ("\n<b>!ПРЕДУПРЕЖДЕНИЕ!</b>\n!Перевод только на карту трейдера!\n!Перевод с другого банка — риск задержек/комиссий!\n" if d.warning_enabled else "") +
            "\nДИСКЛЕЙМЕР"
        )
        # отправка
        tg_ids = await eligible_traders(d)
        for tg_id in tg_ids:
            try:
                await bot.send_message(tg_id, txt, reply_markup=stage1_kb(d.id))
            except Exception:
                continue

@router.callback_query(F.data.startswith("sell1:"))
async def stage1_click(cq: CallbackQuery):
    _, action, deal_id_s = cq.data.split(":",2)
    deal_id = int(deal_id_s)
    async with async_session() as s:
        u = await ensure_user(s, cq.from_user)
        d = await s.get(Deal, deal_id)
        if not d or d.status != DealStatus.OPEN:
            await cq.answer("Сделка недоступна.", show_alert=True); return
        # маржинальное требование по USDT
        if not await ensure_usdt_margin(u.id, float(d.amount_usdt_snapshot)):
            await cq.answer("Недостаточно USDT для участия.", show_alert=True); return
        # записываем участие
        exist = await s.scalar(select(DealParticipant).where(DealParticipant.deal_id==deal_id, DealParticipant.user_id==u.id))
        if not exist:
            p = DealParticipant(deal_id=deal_id, user_id=u.id, accepted=(action=="accept"))
            s.add(p)
        else:
            exist.accepted = (action=="accept")
        # REP
        if action == "accept": u.rep += 1
        else: u.rep -= 2
        await s.commit()
    if action == "accept":
        await cq.message.answer("Отлично! Вы получили +1 REP. Ждите второй этап… ⏳")
    else:
        await cq.message.answer("Очень жаль: −2 REP. Ожидайте другие сделки.")
    await cq.answer()

# ===== Этап 2: приём ставок (FSM) =====
def bid_range_hint(base_pct: float) -> str:
    lo, hi = -5.00, base_pct
    return f"Введите вашу ставку в диапазоне [{lo:.2f}; {hi:.2f}] с шагом 0.01"

@router.message(Command("bid"))
async def bid_help(message: Message):
    await message.answer("Команда для ставки активируется автоматически в Этапе 2.")

# Воркфлоу Этапа 2: по старту раунда воркер создаёт DealRound; мы шлём допущенным инструкцию «введите ставку»
async def notify_round_start(deal_id: int, round_number: int):
    from app.bot import create_bot_and_dp
    bot, _ = create_bot_and_dp("")
    async with async_session() as s:
        d = await s.get(Deal, deal_id)
        if not d: return
        # список допущенных (accepted)
        rows = await s.execute(select(DealParticipant, User.tg_id).join(User, DealParticipant.user_id==User.id)
                               .where(DealParticipant.deal_id==deal_id, DealParticipant.accepted==True))
        for p, tg_id in rows.all():
            try:
                await bot.send_message(int(tg_id),
                    f"<b>АУКЦИОН НАЧАЛСЯ — РАУНД {round_number}</b>\n"
                    f"{bid_range_hint(float(d.base_pct))}\n"
                    f"Отправьте число (например 0.25 или -1.50).")
            except Exception:
                continue

@router.message(BidStates.waiting_bid)
async def accept_bid(message: Message, state: FSMContext):
    data = await state.get_data()
    deal_id = int(data.get("deal_id"))
    try:
        v = float((message.text or "").replace(",", "."))
    except:
        await message.answer("Нужно число. Пример: 0.25 или -2.00"); return
    async with async_session() as s:
        d = await s.get(Deal, deal_id)
        if not d or d.status != DealStatus.BIDDING:
            await message.answer("Приём ставок закрыт."); return
        lo, hi = -5.00, float(d.base_pct)
        # валидация диапазона и шага 0.01
        if v < lo or v > hi or abs(round(v*100) - v*100) > 1e-9:
            await message.answer(bid_range_hint(float(d.base_pct))); return
        # текущий раунд
        r = await s.scalar(select(DealRound).where(DealRound.deal_id==deal_id).order_by(DealRound.round_number.desc()).limit(1))
        if not r:
            await message.answer("Техническая пауза. Попробуйте позже."); return
        # сохранить ставку (последняя перезаписывает)
        exist = await s.scalar(select(Bid).where(Bid.deal_id==deal_id, Bid.round_number==r.round_number, Bid.user_id== (await s.scalar(select(User.id).where(User.tg_id==message.from_user.id)))))
        if exist:
            exist.pct = round(v,2)
        else:
            uid = await s.scalar(select(User.id).where(User.tg_id==message.from_user.id))
            s.add(Bid(deal_id=deal_id, round_number=r.round_number, user_id=uid, pct=round(v,2)))
        await s.commit()
    await message.answer("Ставка принята.")
```

Теперь создам файл `app/handlers/sell_winner.py`:


```python
# app/handlers/sell_winner.py
from __future__ import annotations
from aiogram import Router, F
from aiogram.filters import Command
from aiogram.types import Message, CallbackQuery
from aiogram.utils.keyboard import InlineKeyboardBuilder
from sqlalchemy import select, update
from datetime import datetime, timedelta
from zoneinfo import ZoneInfo

from app.db.base import async_session
from app.db.models import (Deal, DealStatus, TraderProfile, TraderCard, User)
from app.handlers.utils import ensure_user
from app.utils.validation import mask_card
from app.services.balance import release_usdt, consume_reserved_usdt
from app.utils.money import bank_round_2
from app.scheduler import schedule_trader_confirm_window

router = Router(name="sell_winner")
TZ = ZoneInfo("Europe/Amsterdam")

def cards_kb(cards: list[TraderCard], deal_id: int):
    b = InlineKeyboardBuilder()
    for c in cards:
        bank_name = c.bank.value if c.bank.name != "OTHER" else (c.bank_other_name or "ДРУГОЙ БАНК")
        b.button(text=f"{bank_name} • {mask_card(c.card_number)}", callback_data=f"pick:{deal_id}:{c.id}")
    b.adjust(1); return b.as_markup()

@router.message(Command("pick_card"))
async def pick_card_cmd(message: Message):
    # /pick_card <deal_id>
    parts = (message.text or "").split()
    if len(parts) != 2:
        await message.answer("Использование: /pick_card <deal_id>"); return
    deal_id = int(parts[1])
    async with async_session() as s:
        u = await ensure_user(s, message.from_user)
        d = await s.get(Deal, deal_id)
        if not d or d.winner_user_id != u.id:
            await message.answer("Недоступно."); return
        # карты
        prof = await s.scalar(select(TraderProfile).where(TraderProfile.user_id==u.id))
        cards = (await s.execute(select(TraderCard).where(TraderCard.profile_id==prof.id))).scalars().all()
        if not cards:
            await message.answer("У вас нет карт. Обратитесь к администратору."); return
        await message.answer("Выберите карту для получения RUB:", reply_markup=cards_kb(cards, deal_id))

@router.callback_query(F.data.startswith("pick:"))
async def pick_card_cb(cq: CallbackQuery):
    _, deal_id_s, card_id_s = cq.data.split(":",2)
    deal_id, card_id = int(deal_id_s), int(card_id_s)
    async with async_session() as s:
        u = await ensure_user(s, cq.from_user)
        d = await s.get(Deal, deal_id)
        if not d or d.winner_user_id != u.id:
            await cq.answer("Недоступно.", show_alert=True); return
        c = await s.get(TraderCard, card_id)
        if not c:
            await cq.answer("Карта не найдена.", show_alert=True); return
        # Снэпшоты карты
        bank_name = c.bank.value if c.bank.name != "OTHER" else (c.bank_other_name or "ДРУГОЙ БАНК")
        d.winner_card_id = c.id
        d.winner_card_bank = bank_name
        d.winner_card_mask = mask_card(c.card_number)
        d.winner_card_holder = c.holder_name
        d.status = DealStatus.WAITING_ADMIN_TRANSFER
        await s.commit()
    await cq.message.answer(
        "<b>Карта сохранена</b>\n"
        f"Банк: {d.winner_card_bank}\n"
        f"Карта: {d.winner_card_mask}\n"
        f"Держатель: {d.winner_card_holder}\n\n"
        "Ожидайте перевода от администратора."
    )
    # уведомить администратора(ов)
    from app.config import settings
    from app.bot import create_bot_and_dp
    bot, _ = create_bot_and_dp("")
    text_admin = (
        "<b>ПРОДАЖА USDT — переведите RUB победителю</b>\n"
        f"Сделка № <code>{d.deal_no}</code>\n"
        f"Сумма: {float(d.amount_rub):.2f} RUB (~{float(d.amount_usdt_snapshot):.2f} USDT)\n"
        f"Карта: {d.winner_card_bank} • {d.winner_card_mask} • {d.winner_card_holder}\n"
        f"Комментарий: {d.comment or '-'}"
    )
    for admin in settings.admins:
        try:
            await bot.send_message(admin, text_admin, reply_markup=InlineKeyboardBuilder().row(
                InlineKeyboardBuilder().button(text="Перевод выполнен", callback_data=f"adm:paid:{deal_id}"),
                InlineKeyboardBuilder().button(text="Проблема с картой", callback_data=f"adm:card:{deal_id}")
            ).as_markup())
        except Exception:
            continue
    await cq.answer()

@router.callback_query(F.data.startswith("adm:paid:"))
async def admin_paid(cq: CallbackQuery):
    deal_id = int(cq.data.split(":",2)[2])
    async with async_session() as s:
        d = await s.get(Deal, deal_id)
        if not d: return await cq.answer()
        d.status = DealStatus.WAITING_TRADER_CONFIRM
        await s.commit()
    # окно подтверждения трейдера (10 мин)
    await schedule_trader_confirm_window(deal_id, after_minutes=10)
    await cq.message.answer("Ок. Ожидаем подтверждение от трейдера.")
    await cq.answer()

@router.callback_query(F.data.startswith("adm:card:"))
async def admin_card_issue(cq: CallbackQuery):
    deal_id = int(cq.data.split(":",2)[2])
    async with async_session() as s:
        d = await s.get(Deal, deal_id)
        if not d: return await cq.answer()
        # пауза таймера не реализована детально — можно просто отложить задачу вручную
        await cq.message.answer("Отмечено. Свяжитесь с трейдером для смены карты.")
    await cq.answer()

def winner_actions_kb(deal_id: int):
    b = InlineKeyboardBuilder()
    b.button(text="Я ПОЛУЧИЛ ПЕРЕВОД", callback_data=f"win:got:{deal_id}")
    b.button(text="СМЕНИТЬ КАРТУ", callback_data=f"win:card:{deal_id}")
    b.button(text="ОТМЕНА СДЕЛКИ −200 RUB", callback_data=f"win:cancel:{deal_id}")
    b.button(text="ОПЕРАТОР", callback_data=f"win:op:{deal_id}")
    b.adjust(1,2,1); return b.as_markup()

@router.callback_query(F.data.startswith("win:got:"))
async def winner_got_money(cq: CallbackQuery):
    deal_id = int(cq.data.split(":",2)[2])
    async with async_session() as s:
        d = await s.get(Deal, deal_id)
        if not d or d.status not in (DealStatus.WAITING_ADMIN_TRANSFER, DealStatus.WAITING_TRADER_CONFIRM):
            await cq.answer("Недоступно.", show_alert=True); return
        # финальные расчёты
        reward_rub = bank_round_2(float(d.amount_rub) * float(d.winner_bid_pct)/100.0)
        fee_rub = bank_round_2(reward_rub * float(d.service_fee_pct)/100.0) if reward_rub > 0 else 0.0
        # списать резерв USDT
        await consume_reserved_usdt(int(d.winner_user_id), float(d.amount_usdt_snapshot))
        # применить вознаграждение к RUB-балансу победителя
        u = await s.get(User, int(d.winner_user_id))
        if reward_rub >= 0:
            u.balance_rub = float(u.balance_rub) + (reward_rub - fee_rub)
        else:
            u.balance_rub = float(u.balance_rub) - abs(reward_rub)
        d.status = DealStatus.COMPLETED
        await s.commit()
    await cq.message.answer("Сделка завершена. Спасибо!")
    await cq.answer()

@router.callback_query(F.data.startswith("win:cancel:"))
async def winner_cancel(cq: CallbackQuery):
    deal_id = int(cq.data.split(":",2)[2])
    async with async_session() as s:
        d = await s.get(Deal, deal_id)
        if not d: return
        # штраф −200 RUB, резерв USDT вернуть
        u = await s.get(User, int(d.winner_user_id))
        u.balance_rub = float(u.balance_rub) - 200.0
        await release_usdt(int(d.winner_user_id), float(d.amount_usdt_snapshot))
        d.status = DealStatus.CANCELLED_BY_TRADER
        await s.commit()
    await cq.message.answer("Сделка отменена. Штраф −200 RUB применён.")
    await cq.answer()

@router.callback_query(F.data.startswith("win:card:"))
async def winner_change_card(cq: CallbackQuery):
    # простая переотправка вы
```

```python
# app/handlers/sell_winner.py
from __future__ import annotations
from aiogram import Router, F
from aiogram.filters import Command
from aiogram.types import Message, CallbackQuery
from aiogram.utils.keyboard import InlineKeyboardBuilder
from sqlalchemy import select, update
from datetime import datetime, timedelta
from zoneinfo import ZoneInfo

from app.db.base import async_session
from app.db.models import (Deal, DealStatus, TraderProfile, TraderCard, User)
from app.handlers.utils import ensure_user
from app.utils.validation import mask_card
from app.services.balance import release_usdt, consume_reserved_usdt
from app.utils.money import bank_round_2
from app.scheduler import schedule_trader_confirm_window

router = Router(name="sell_winner")
TZ = ZoneInfo("Europe/Amsterdam")

def cards_kb(cards: list[TraderCard], deal_id: int):
    b = InlineKeyboardBuilder()
    for c in cards:
        bank_name = c.bank.value if c.bank.name != "OTHER" else (c.bank_other_name or "ДРУГОЙ БАНК")
        b.button(text=f"{bank_name} • {mask_card(c.card_number)}", callback_data=f"pick:{deal_id}:{c.id}")
    b.adjust(1); return b.as_markup()

@router.message(Command("pick_card"))
async def pick_card_cmd(message: Message):
    # /pick_card <deal_id>
    parts = (message.text or "").split()
    if len(parts) != 2:
        await message.answer("Использование: /pick_card <deal_id>"); return
    deal_id = int(parts[1])
    async with async_session() as s:
        u = await ensure_user(s, message.from_user)
        d = await s.get(Deal, deal_id)
        if not d or d.winner_user_id != u.id:
            await message.answer("Недоступно."); return
        # карты
        prof = await s.scalar(select(TraderProfile).where(TraderProfile.user_id==u.id))
        cards = (await s.execute(select(TraderCard).where(TraderCard.profile_id==prof.id))).scalars().all()
        if not cards:
            await message.answer("У вас нет карт. Обратитесь к администратору."); return
        await message.answer("Выберите карту для получения RUB:", reply_markup=cards_kb(cards, deal_id))

@router.callback_query(F.data.startswith("pick:"))
async def pick_card_cb(cq: CallbackQuery):
    _, deal_id_s, card_id_s = cq.data.split(":",2)
    deal_id, card_id = int(deal_id_s), int(card_id_s)
    async with async_session() as s:
        u = await ensure_user(s, cq.from_user)
        d = await s.get(Deal, deal_id)
        if not d or d.winner_user_id != u.id:
            await cq.answer("Недоступно.", show_alert=True); return
        c = await s.get(TraderCard, card_id)
        if not c:
            await cq.answer("Карта не найдена.", show_alert=True); return
        # Снэпшоты карты
        bank_name = c.bank.value if c.bank.name != "OTHER" else (c.bank_other_name or "ДРУГОЙ БАНК")
        d.winner_card_id = c.id
        d.winner_card_bank = bank_name
        d.winner_card_mask = mask_card(c.card_number)
        d.winner_card_holder = c.holder_name
        d.status = DealStatus.WAITING_ADMIN_TRANSFER
        await s.commit()
    await cq.message.answer(
        "<b>Карта сохранена</b>\n"
        f"Банк: {d.winner_card_bank}\n"
        f"Карта: {d.winner_card_mask}\n"
        f"Держатель: {d.winner_card_holder}\n\n"
        "Ожидайте перевода от администратора."
    )
    # уведомить администратора(ов)
    from app.config import settings
    from app.bot import create_bot_and_dp
    bot, _ = create_bot_and_dp("")
    text_admin = (
        "<b>ПРОДАЖА USDT — переведите RUB победителю</b>\n"
        f"Сделка № <code>{d.deal_no}</code>\n"
        f"Сумма: {float(d.amount_rub):.2f} RUB (~{float(d.amount_usdt_snapshot):.2f} USDT)\n"
        f"Карта: {d.winner_card_bank} • {d.winner_card_mask} • {d.winner_card_holder}\n"
        f"Комментарий: {d.comment or '-'}"
    )
    for admin in settings.admins:
        try:
            await bot.send_message(admin, text_admin, reply_markup=InlineKeyboardBuilder().row(
                InlineKeyboardBuilder().button(text="Перевод выполнен", callback_data=f"adm:paid:{deal_id}"),
                InlineKeyboardBuilder().button(text="Проблема с картой", callback_data=f"adm:card:{deal_id}")
            ).as_markup())
        except Exception:
            continue
    await cq.answer()

@router.callback_query(F.data.startswith("adm:paid:"))
async def admin_paid(cq: CallbackQuery):
    deal_id = int(cq.data.split(":",2)[2])
    async with async_session() as s:
        d = await s.get(Deal, deal_id)
        if not d: return await cq.answer()
        d.status = DealStatus.WAITING_TRADER_CONFIRM
        await s.commit()
    # окно подтверждения трейдера (10 мин)
    await schedule_trader_confirm_window(deal_id, after_minutes=10)
    await cq.message.answer("Ок. Ожидаем подтверждение от трейдера.")
    await cq.answer()

@router.callback_query(F.data.startswith("adm:card:"))
async def admin_card_issue(cq: CallbackQuery):
    deal_id = int(cq.data.split(":",2)[2])
    async with async_session() as s:
        d = await s.get(Deal, deal_id)
        if not d: return await cq.answer()
        # пауза таймера не реализована детально — можно просто отложить задачу вручную
        await cq.message.answer("Отмечено. Свяжитесь с трейдером для смены карты.")
    await cq.answer()

def winner_actions_kb(deal_id: int):
    b = InlineKeyboardBuilder()
    b.button(text="Я ПОЛУЧИЛ ПЕРЕВОД", callback_data=f"win:got:{deal_id}")
    b.button(text="СМЕНИТЬ КАРТУ", callback_data=f"win:card:{deal_id}")
    b.button(text="ОТМЕНА СДЕЛКИ −200 RUB", callback_data=f"win:cancel:{deal_id}")
    b.button(text="ОПЕРАТОР", callback_data=f"win:op:{deal_id}")
    b.adjust(1,2,1); return b.as_markup()

@router.callback_query(F.data.startswith("win:got:"))
async def winner_got_money(cq: CallbackQuery):
    deal_id = int(cq.data.split(":",2)[2])
    async with async_session() as s:
        d = await s.get(Deal, deal_id)
        if not d or d.status not in (DealStatus.WAITING_ADMIN_TRANSFER, DealStatus.WAITING_TRADER_CONFIRM):
            await cq.answer("Недоступно.", show_alert=True); return
        # финальные расчёты
        reward_rub = bank_round_2(float(d.amount_rub) * float(d.winner_bid_pct)/100.0)
        fee_rub = bank_round_2(reward_rub * float(d.service_fee_pct)/100.0) if reward_rub > 0 else 0.0
        # списать резерв USDT
        await consume_reserved_usdt(int(d.winner_user_id), float(d.amount_usdt_snapshot))
        # применить вознаграждение к RUB-балансу победителя
        u = await s.get(User, int(d.winner_user_id))
        if reward_rub >= 0:
            u.balance_rub = float(u.balance_rub) + (reward_rub - fee_rub)
        else:
            u.balance_rub = float(u.balance_rub) - abs(reward_rub)
        d.status = DealStatus.COMPLETED
        await s.commit()
    await cq.message.answer("Сделка завершена. Спасибо!")
    await cq.answer()

@router.callback_query(F.data.startswith("win:cancel:"))
async def winner_cancel(cq: CallbackQuery):
    deal_id = int(cq.data.split(":",2)[2])
    async with async_session() as s:
        d = await s.get(Deal, deal_id)
        if not d: return
        # штраф −200 RUB, резерв USDT вернуть
        u = await s.get(User, int(d.winner_user_id))
        u.balance_rub = float(u.balance_rub) - 200.0
        await release_usdt(int(d.winner_user_id), float(d.amount_usdt_snapshot))
        d.status = DealStatus.CANCELLED_BY_TRADER
        await s.commit()
    await cq.message.answer("Сделка отменена. Штраф −200 RUB применён.")
    await cq.answer()

@router.callback_query(F.data.startswith("win:card:"))
async def winner_change_card(cq: CallbackQuery):
    # простая переотправка выбора карт
    deal_id = int(cq.data.split(":",2)[2])
    async with async_session() as s:
        u = await ensure_user(s, cq.from_user)
        d = await s.get(Deal, deal_id)
        prof = await s.scalar(select(TraderProfile).where(TraderProfile.user_id==u.id))
        cards = (await s.execute(select(TraderCard).where(TraderCard.profile_id==prof.id))).scalars().all()
    await cq.message.answer("Выберите новую карту:", reply_markup=cards_kb(cards, deal_id))
    await cq.answer()
```

Теперь обновлю файл `app/bot.py` для подключения новых роутеров:


Теперь обновлю файл `app/bot.py`:


```python
from aiogram import Bot, Dispatcher
from aiogram.enums import ParseMode
from aiogram.client.default import DefaultBotProperties

from app.config import settings
from app.handlers.common import router as common_router
from app.handlers.auth import router as auth_router
from app.handlers.admin import router as admin_router
from app.handlers.trader import router as trader_router
from app.logging_setup import get_logger

logger = get_logger(__name__)


def create_bot() -> Bot:
    """Создание экземпляра бота."""
    bot = Bot(
        token=settings.bot_token,
        default=DefaultBotProperties(parse_mode=ParseMode.HTML)
    )
    logger.info("Бот создан")
    return bot


def create_dispatcher() -> Dispatcher:
    """Создание диспетчера и подключение роутеров."""
    dp = Dispatcher()
    
    # Подключаем роутеры
    dp.include_router(common_router)
    dp.include_router(auth_router)
    dp.include_router(admin_router)
    dp.include_router(trader_router)
    
    # Подключаем новые роутеры
    from app.handlers.admin_settings import router as admin_settings_router
    from app.handlers.admin_deals import router as admin_deals_router
    from app.handlers.admin_deals_sell import router as admin_deals_sell_router
    from app.handlers.sell_auction import router as sell_auction_router
    from app.handlers.sell_winner import router as sell_winner_router
    
    dp.include_router(admin_settings_router)
    dp.include_router(admin_deals_router)
    dp.include_router(admin_deals_sell_router)
    dp.include_router(sell_auction_router)
    dp.include_router(sell_winner_router)
    
    logger.info("Диспетчер создан и роутеры подключены")
    return dp

def create_bot_and_dp(bot_token: str):
    """Создание бота и диспетчера с переданным токеном."""
    bot = Bot(
        token=(bot_token or ""),
        default=DefaultBotProperties(parse_mode=ParseMode.HTML)
    )
    dp = create_dispatcher()
    return bot, dp
```

Теперь обновлю файл `README.md`:


Теперь добавлю раздел о продаже USDT в README.md:


```markdown
# Telegram Bot для аукционов

Бот для управления аукционами с системой ролей и токен-доступа.

## Возможности

- Система ролей: Администратор, Трейдер, Оператор
- Управление профилями трейдеров
- Система карт с поддержкой СБП
- Аукционы и ставки
- Планировщик задач

## Установка

1. Клонируйте репозиторий
2. Создайте виртуальное окружение: `python -m venv venv`
3. Активируйте окружение: `venv\Scripts\activate` (Windows) или `source venv/bin/activate` (Linux/Mac)
4. Установите зависимости: `pip install -r requirements.txt`
5. Скопируйте `.env.example` в `.env` и настройте переменные
6. Запустите бота: `python -m app.main`

## Настройка .env

```env
BOT_TOKEN=your_bot_token_here
DATABASE_URL=sqlite+aiosqlite:///data/app.db
SCHEDULER_DB_URL=sqlite:///data/scheduler.db
ADMINS=123456789,987654321
```

## Авторизация

Доступ к функционалу трейдера — только по токену.

### Процесс регистрации:

1. **Админ** создаёт профиль командой `/admin` → "Зарегистрировать трейдера"
2. Проходит мастер регистрации: ID, ник, имя, телефон, реф.код, карты
3. Получает 20-символьный токен доступа (A-Z0-9)

### Процесс активации:

1. **Трейдер** вводит команду `/access`
2. Вставляет полученный токен
3. После активации доступен `/menu` с профилем и картами
4. Кнопка "Онлайн/Оффлайн" переключает получение заявок

### Ограничения:

- Пока пользователь не активирован (`is_active=0`) — любые трейдерские действия недоступны
- Бот просит ввести токен при попытке доступа к функционалу
- Токен одноразовый, после использования помечается как потреблённый

## Команды

- `/start` - приветствие и проверка роли
- `/admin` - панель администратора (только для админов)
- `/access` - ввод токена доступа (для трейдеров)
- `/menu` - личный кабинет трейдера (только после активации)
- `/ping` - проверка работоспособности
- `/health` - статус системы
- `/settings` - настройки системы (только для админов)
- `/deals` - управление сделками (только для админов)

## Структура проекта

```
app/
├── __init__.py
├── main.py              # Главный модуль
├── bot.py               # Создание бота и диспетчера
├── config.py            # Конфигурация
├── db/
│   ├── __init__.py
│   ├── base.py          # Подключение к БД
│   └── models.py        # Модели данных
├── handlers/
│   ├── __init__.py
│   ├── common.py        # Общие команды
│   ├── auth.py          # Авторизация по токену
│   ├── admin.py         # Админ-панель
│   ├── admin_settings.py # Настройки системы
│   ├── admin_deals.py   # Управление сделками
│   ├── trader.py        # Меню трейдера
│   └── utils.py         # Утилиты
├── services/
│   ├── __init__.py
│   └── settings.py      # Сервис настроек
├── utils/
│   ├── __init__.py
│   ├── validation.py    # Валидация данных
│   └── money.py         # Утилиты для денег
├── scheduler.py          # Планировщик задач
└── logging_setup.py     # Настройка логирования
```

## База данных

SQLite с поддержкой:
- Пользователи с ролями и статусами
- Профили трейдеров
- Банковские карты с СБП
- Токены доступа
- Аукционы и ставки
- Системные настройки (курс валют, комиссии)
- Аудит изменений настроек

## Настройки комиссии сервиса

Команда `/settings` (для админа) → «Финансы»:
- Курс RUB/USDT
- Service Fee (дефолт), мин/макс, флаг «Переопределение в сделке»
- Длительность раунда и число добавочных раундов

В мастере «Покупка» поле «Комиссия сервиса, %» предзаполняется дефолтом и валидируется по диапазону; при выключенном переопределении поле не запрашивается, в сделку пишется дефолт.

В сделке хранится снэпшот `service_fee_pct`, который используется в расчётах независимо от будущих изменений настроек.

## Продажа USDT

Команда `/sell` (админ) — мастер: сумма в RUB → база % → комиссия сервиса % → аудитория → время → комментарий → предупреждение → публикация.

**Этап 1**: рассылка только онлайн-трейдерам с USDT-маржой (баланс USDT ≥ требуемого) и с хотя бы одной картой. Принять = +1 REP, Отклонить = −2 REP.

**Этап 2/3**: торги, допустимый диапазон ставок [−5.00; base_pct], шаг 0.01. Ничья → доп.раунды (до 5), затем случайный выбор.

**Победитель**: USDT резервируется, трейдер выбирает карту, админ получает реквизиты карты и отмечает «Перевод выполнен». Трейдер подтверждает «Я получил перевод» → USDT списываются из резерва, к RUB-балансу применяется вознаграждение, комиссия сервиса удерживается из положительного вознаграждения.

**Отмена победителем**: −200 RUB и отмена; тайм-аут оплаты админом: CANCELLED_TIMEOUT без штрафа, резерв возвращается.

## Разработка

Для добавления новых функций:
1. Создайте обработчик в `handlers/`
2. Зарегистрируйте роутер в `bot.py`
3. Обновите модели в `db/models.py` при необходимости
4. Добавьте команды в README.md
```

Теперь нужно создать директорию `app/workers` и файл `__init__.py`:


```python
# app/workers package
```

Теперь нужно исправить импорт в `app/scheduler.py` - заменить `async_session` на правильный импорт:


Теперь исправлю импорт в `app/scheduler.py`:


```python
from datetime import datetime, timedelta
from typing import Optional
from zoneinfo import ZoneInfo

from apscheduler.schedulers.asyncio import AsyncIOScheduler
from apscheduler.jobstores.sqlalchemy import SQLAlchemyJobStore
from sqlalchemy import select, update

from app.config import settings
from app.db.base import async_session
from app.db.models import Deal, DealStatus
from app.logging_setup import get_logger

logger = get_logger(__name__)


class AuctionScheduler:
    """Планировщик задач для аукциона."""
    
    def __init__(self):
        self.scheduler: Optional[AsyncIOScheduler] = None
    
    def init_scheduler(self) -> None:
        """Инициализация планировщика."""
        # Создаем хранилище задач в SQLite
        jobstore = SQLAlchemyJobStore(
            url=settings.scheduler_db_url,
            tablename='apscheduler_jobs'
        )
        
        # Создаем планировщик
        self.scheduler = AsyncIOScheduler(
            timezone="Europe/Amsterdam",
            jobstores={'default': jobstore}
        )
        
        logger.info("Планировщик инициализирован")
    
    def start_scheduler(self) -> None:
        """Запуск планировщика."""
        if self.scheduler is None:
            raise RuntimeError("Планировщик не инициализирован")
        
        # Регистрируем задачи
        self._register_jobs()
        
        # Запускаем планировщик
        self.scheduler.start()
        logger.info("Планировщик запущен")
    
    def stop_scheduler(self) -> None:
        """Остановка планировщика."""
        if self.scheduler is not None:
            self.scheduler.shutdown()
            logger.info("Планировщик остановлен")
    
    def _register_jobs(self) -> None:
        """Регистрация задач в планировщике."""
        if self.scheduler is None:
            return
        
        # Heartbeat каждую минуту
        self.scheduler.add_job(
            heartbeat,
            'interval',
            minutes=1,
            id='heartbeat',
            replace_existing=True,
            max_instances=1
        )
        
        # Закрытие просроченных сделок каждую минуту
        self.scheduler.add_job(
            close_expired_deals,
            'interval',
            minutes=1,
            id='close_expired_deals',
            replace_existing=True,
            max_instances=1
        )
        
        logger.info("Задачи зарегистрированы в планировщике")


async def heartbeat() -> None:
    """Задача heartbeat для проверки работы планировщика."""
    logger.info("💓 Heartbeat от планировщика")


async def close_expired_deals() -> None:
    """Закрытие просроченных сделок."""
    try:
        now = datetime.now(ZoneInfo("Europe/Amsterdam"))
        closed_count = 0
        
        async with async_session() as s:
            # Находим просроченные открытые сделки по pay_deadline_at
            result = await s.execute(
                select(Deal).where(
                    Deal.status == DealStatus.OPEN,
                    Deal.pay_deadline_at <= now
                )
            )
            expired_deals = result.scalars().all()
            
            if expired_deals:
                # Закрываем сделки атомарно
                await s.execute(
                    update(Deal)
                    .where(
                        Deal.status == DealStatus.OPEN,
                        Deal.pay_deadline_at <= now
                    )
                    .values(status=DealStatus.EXPIRED_PENALTY)
                )
                
                await s.commit()
                closed_count = len(expired_deals)
                
                logger.info(f"Закрыто {closed_count} просроченных сделок")
            else:
                logger.debug("Просроченных сделок не найдено")
        
        if closed_count > 0:
            logger.info(f"✅ Задача закрытия сделок выполнена: закрыто {closed_count} сделок")
        
    except Exception as e:
        logger.error(f"Ошибка при закрытии просроченных сделок: {e}")


# Глобальный экземпляр планировщика
scheduler = AuctionScheduler()

# ---- Новые функции для постановки задач аукциона ----
async def schedule_stage1_end(deal_id: int, after_seconds: int):
    get_scheduler().add_job("app.workers.auction:end_stage1", "date",
                            run_date=datetime.now(ZoneInfo("Europe/Amsterdam"))+timedelta(seconds=after_seconds),
                            args=[deal_id], id=f"deal:{deal_id}:stage1", replace_existing=True)

async def schedule_round_end(deal_id: int, round_number: int, after_seconds: int):
    get_scheduler().add_job("app.workers.auction:end_round", "date",
                            run_date=datetime.now(ZoneInfo("Europe/Amsterdam"))+timedelta(seconds=after_seconds),
                            args=[deal_id, round_number], id=f"deal:{deal_id}:round:{round_number}",
                            replace_existing=True)

async def schedule_pay_timeout(deal_id: int, after_minutes: int):
    get_scheduler().add_job("app.workers.auction:pay_timeout", "date",
                            run_date=datetime.now(ZoneInfo("Europe/Amsterdam"))+timedelta(minutes=after_minutes),
                            args=[deal_id], id=f"deal:{deal_id}:pay", replace_existing=True)

async def schedule_trader_confirm_window(deal_id: int, after_minutes: int = 10):
    get_scheduler().add_job("app.workers.auction:trader_confirm_timeout", "date",
                            run_date=datetime.now(ZoneInfo("Europe/Amsterdam"))+timedelta(minutes=after_minutes),
                            args=[deal_id], id=f"deal:{deal_id}:confirm", replace_existing=True)

def get_scheduler() -> AsyncIOScheduler:
    return scheduler.scheduler
```

Теперь нужно исправить импорт в `app/workers/auction.py`:


```python
# app/workers/auction.py
from __future__ import annotations
from datetime import datetime, timedelta
from zoneinfo import ZoneInfo
from sqlalchemy import select, func, update, and_, asc
from aiogram import Bot

from app.config import settings
from app.db.base import async_session
from app.db.models import (Deal, DealStatus, DealRound, DealParticipant, Bid, User, TraderCard)
from app.services.balance import reserve_usdt, release_usdt, consume_reserved_usdt
from app.utils.money import bank_round_2
from app.logging_setup import get_logger

logger = get_logger(__name__)
TZ = ZoneInfo("Europe/Amsterdam")

async def _get_bot() -> Bot:
    from app.bot import create_bot_and_dp
    bot, _ = create_bot_and_dp(settings.bot_token)
    return bot

# ---- Завершение Этапа 1: формируем список допущенных и запускаем торги (раунд 1) ----
async def end_stage1(deal_id: int):
    async with async_session() as s:
        deal = await s.get(Deal, deal_id)
        if not deal or deal.status != DealStatus.OPEN:
            return
        deal.status = DealStatus.BIDDING
        # старт раунда 1
        round_secs = int(deal.round_secs or 20)
        dr = DealRound(deal_id=deal.id, round_number=1,
                       started_at=datetime.now(TZ),
                       deadline_at=datetime.now(TZ) + timedelta(seconds=round_secs))
        s.add(dr)
        await s.commit()
    # Запланируем завершение раунда
    from app.scheduler import schedule_round_end
    await schedule_round_end(deal_id, 1, round_secs)
    
    # Уведомляем участников о начале торгов
    from app.handlers.sell_auction import notify_round_start
    await notify_round_start(deal_id, 1)

# ---- Завершение любого раунда: определяем минимум, ничьи -> новый раунд/иначе победитель ----
async def end_round(deal_id: int, round_number: int):
    async with async_session() as s:
        deal = await s.get(Deal, deal_id)
        if not deal or deal.status != DealStatus.BIDDING:
            return
        # найти минимальную ставку на этом раунде
        res = await s.execute(select(Bid.pct).where(Bid.deal_id==deal_id, Bid.round_number==round_number).order_by(asc(Bid.pct)))
        rows = [float(r[0]) for r in res.all()]
        if not rows:
            # никто не сделал ставку — отменяем без штрафов
            deal.status = DealStatus.CANCELLED
            await s.commit()
            return
        min_pct = rows[0]
        # кто поставил минимум?
        res2 = await s.execute(select(Bid.user_id).where(Bid.deal_id==deal_id, Bid.round_number==round_number, Bid.pct==min_pct))
        users = [int(r[0]) for r in res2.all()]
        if len(users) > 1:
            # ничья
            if round_number >= int(deal.max_tie_rounds or 5):
                # случайный победитель из ничьей
                import random
                winner_id = random.choice(users)
                deal.winner_user_id = winner_id
                deal.winner_bid_pct = min_pct
                deal.status = DealStatus.WINNER_ASSIGNED
                await s.commit()
                await _after_winner_assigned(s, deal)
                return
            # иначе новый раунд только среди этих пользователей
            next_round = round_number + 1
            dr = DealRound(deal_id=deal.id, round_number=next_round,
                           started_at=datetime.now(TZ),
                           deadline_at=datetime.now(TZ) + timedelta(seconds=int(deal.round_secs or 20)))
            s.add(dr)
            await s.commit()
            from app.scheduler import schedule_round_end
            await schedule_round_end(deal_id, next_round, int(deal.round_secs or 20))
            
            # Уведомляем участников о новом раунде
            from app.handlers.sell_auction import notify_round_start
            await notify_round_start(deal_id, next_round)
            return
        # один победитель
        winner_id = users[0]
        deal.winner_user_id = winner_id
        deal.winner_bid_pct = min_pct
        deal.status = DealStatus.WINNER_ASSIGNED
        await s.commit()
    await _after_winner_assigned(None, deal_id=deal_id)

async def _after_winner_assigned(s_in: any = None, deal_id: int | None = None, deal: Deal | None = None):
    # Резерв USDT, запрос выбрать карту, старт таймера для админа
    if not deal:
        async with async_session() as s:
            deal = await s.get(Deal, deal_id)
    if not deal: return
    from app.scheduler import schedule_pay_timeout
    # резерв USDT у победителя
    ok = await reserve_usdt(int(deal.winner_user_id), float(deal.amount_usdt_snapshot))
    if not ok:
        # не смогли зарезервировать (параллельная трата) -> отмена
        async with async_session() as s:
            d = await s.get(Deal, deal.id)
            d.status = DealStatus.CANCELLED
            await s.commit()
        return
    # попросим победителя выбрать карту
    bot = await _get_bot()
    await bot.send_message(int(await _winner_tg_id(deal.winner_user_id)),
        f"<b>Вы выиграли аукцион — ПРОДАЖА USDT</b>\n"
        f"Сделка № <code>{deal.deal_no}</code>\n"
        f"Сумма: {float(deal.amount_rub):.2f} RUB (~{float(deal.amount_usdt_snapshot):.2f} USDT)\n"
        f"Ваша ставка: {float(deal.winner_bid_pct):.2f}%\n\n"
        f"Выберите карту, на которую придут RUB: /pick_card {deal.id}")
    # старт общего таймера оплаты для админа
    await schedule_pay_timeout(deal.id, after_minutes=_minutes_from_deadline(deal))

def _minutes_from_deadline(deal: Deal) -> int:
    # в модели мы не храним «минуты» отдельно; можно вычислить по настройке/состоянию
    return 20  # безопасное дефолтное значение; реальное время задаётся при создании сделки (см. handler)

async def pay_timeout(deal_id: int):
    # админ не успел отправить — отмена без штрафа, резервы вернуть
    async with async_session() as s:
        d = await s.get(Deal, deal_id)
        if not d or d.status not in (DealStatus.WINNER_ASSIGNED, DealStatus.WAITING_ADMIN_TRANSFER):
            return
        if d.winner_user_id:
            await release_usdt(int(d.winner_user_id), float(d.amount_usdt_snapshot))
        d.status = DealStatus.CANCELLED_TIMEOUT
        await s.commit()

async def trader_confirm_timeout(deal_id: int):
    # окно подтверждения трейдером истекло — оператор решает вручную; оставим REVIEW
    async with async_session() as s:
        d = await s.get(Deal, deal_id)
        if not d or d.status != DealStatus.WAITING_TRADER_CONFIRM:
            return
        d.status = DealStatus.REVIEW
        await s.commit()

async def _winner_tg_id(user_id: int) -> int:
    async with async_session() as s:
        u = await s.get(User, user_id)
        return int(u.tg_id or 0)
```

Теперь нужно исправить импорт в `app/services/balance.py`:


```python
# app/services/balance.py
from __future__ import annotations
from sqlalchemy import select, update
from app.db.base import async_session
from app.db.models import User

async def ensure_usdt_margin(user_id: int, need_usdt: float) -> bool:
    async with async_session() as s:
        u = await s.get(User, user_id)
        return float(u.balance_usdt) >= need_usdt

async def reserve_usdt(user_id: int, amount: float) -> bool:
    """Перенос amount из balance_usdt в reserved_usdt. Возвращает True, если успешно."""
    async with async_session() as s:
        u = await s.get(User, user_id)
        if float(u.balance_usdt) < amount: return False
        u.balance_usdt = float(u.balance_usdt) - amount
        u.reserved_usdt = float(u.reserved_usdt) + amount
        await s.commit()
        return True

async def release_usdt(user_id: int, amount: float) -> None:
    """Возврат резерва в баланс."""
    async with async_session() as s:
        u = await s.get(User, user_id)
        u.reserved_usdt = max(0.0, float(u.reserved_usdt) - amount)
        u.balance_usdt = float(u.balance_usdt) + amount
        await s.commit()

async def consume_reserved_usdt(user_id: int, amount: float) -> bool:
    """Окончательное списание из резерва (не возвращаем на баланс)."""
    async with async_session() as s:
        u = await s.get(User, user_id)
        if float(u.reserved_usdt) < amount: return False
        u.reserved_usdt = float(u.reserved_usdt) - amount
        await s.commit()
        return True
```

Теперь нужно исправить импорт в `app/handlers/admin_deals_sell.py`:


```python
# app/handlers/admin_deals_sell.py
from __future__ import annotations
from aiogram import Router, F
from aiogram.filters import Command
from aiogram.fsm.state import State, StatesGroup
from aiogram.fsm.context import FSMContext
from aiogram.types import Message, CallbackQuery
from aiogram.utils.keyboard import InlineKeyboardBuilder
from sqlalchemy import select
from datetime import datetime, timedelta
from zoneinfo import ZoneInfo
import json

from app.config import settings
from app.db.base import async_session
from app.db.models import RoleEnum, User, Deal, DealType, DealStatus
from app.handlers.utils import ensure_user
from app.services.settings import get_settings
from app.utils.money import bank_round_2
from app.utils.validation import validate_decimal_range_step
from app.scheduler import schedule_stage1_end

router = Router(name="admin_deals_sell")
TZ = ZoneInfo("Europe/Amsterdam")

class SellStates(StatesGroup):
    amount_rub = State()
    base_pct = State()
    service_fee = State()
    audience = State()
    audience_params = State()
    pay_time = State()
    comment_ask = State()
    comment_text = State()
    warning_toggle = State()
    confirm = State()

def kb_yesno(cb_yes: str, cb_no: str):
    b = InlineKeyboardBuilder()
    b.button(text="Да", callback_data=cb_yes)
    b.button(text="Нет", callback_data=cb_no)
    b.adjust(2); return b.as_markup()

def kb_audience():
    b = InlineKeyboardBuilder()
    b.button(text="Для всех (онлайн + USDT маржа + карта)", callback_data="aud:all")
    b.button(text="По рейтингу", callback_data="aud:rep")
    b.button(text="Персонально", callback_data="aud:per")
    b.adjust(1)
    return b.as_markup()

@router.message(Command("sell"))
async def sell_menu(message: Message, state: FSMContext):
    async with async_session() as s:
        u = await ensure_user(s, message.from_user)
        if u.role != RoleEnum.admin:
            await message.answer("Доступно только администратору.")
            return
    await state.clear()
    await state.set_state(SellStates.amount_rub)
    await message.answer("1) Введите сумму сделки в RUB:")

@router.message(SellStates.amount_rub)
async def step_amount(message: Message, state: FSMContext):
    try:
        rub = float((message.text or "").replace(" ", "").replace(",", "."))
        if rub <= 0: raise ValueError
        s = await get_settings()
        usdt = bank_round_2(rub / float(s.rub_per_usdt))
        await state.update_data(amount_rub=bank_round_2(rub), amount_usdt=usdt)
        await state.set_state(SellStates.base_pct)
        await message.answer(f"USDT эквивалент: ~ {usdt:.2f}\n2) Вознаграждение трейдера, % (−5.00..+25.00):")
    except Exception:
        await message.answer("Некорректная сумма. Повторите ввод.")

@router.message(SellStates.base_pct)
async def step_base_pct(message: Message, state: FSMContext):
    try:
        v = float((message.text or "").replace(",", "."))
        if not validate_decimal_range_step(v, -5.00, 25.00, 0.01): raise ValueError
        await state.update_data(base_pct=round(v,2))
        s = await get_settings()
        if s.service_fee_overridable:
            await state.set_state(SellStates.service_fee)
            await message.answer(f"3) Комиссия сервиса, % (диапазон {s.service_fee_min_pct:.2f}..{s.service_fee_max_pct:.2f}), шаг 0.01.\nПо умолчанию {s.service_fee_default_pct:.2f}%")
        else:
            await state.update_data(service_fee_pct=float(s.service_fee_default_pct))
            await state.set_state(SellStates.audience)
            await message.answer("4) Выберите аудиторию:", reply_markup=kb_audience())
    except Exception:
        await message.answer("Неверное значение. Введите в диапазоне −5.00..+25.00 с шагом 0.01.")

@router.message(SellStates.service_fee)
async def step_service_fee(message: Message, state: FSMContext):
    from app.services.settings import get_settings
    s = await get_settings()
    try:
        v = float((message.text or "").replace(",", "."))
        if not validate_decimal_range_step(v, float(s.service_fee_min_pct), float(s.service_fee_max_pct), 0.01): raise ValueError
        await state.update_data(service_fee_pct=round(v,2))
        await state.set_state(SellStates.audience)
        await message.answer("4) Выберите аудиторию:", reply_markup=kb_audience())
    except Exception:
        await message.answer(f"Неверно. Введите значение в диапазоне {float(s.service_fee_min_pct):.2f}..{float(s.service_fee_max_pct):.2f} с шагом 0.01.")

@router.callback_query(SellStates.audience, F.data.startswith("aud:"))
async def step_audience(cq: CallbackQuery, state: FSMContext):
    mode = cq.data.split(":",1)[1]
    await state.update_data(audience_type=mode)
    if mode == "rep":
        await state.set_state(SellStates.audience_params)
        await cq.message.answer("Укажите REP диапазон: 'от до' (можно оставить пустым один конец). Пример: '10 100' или '10' или ' 100'")
    elif mode == "per":
        await state.set_state(SellStates.audience_params)
        await cq.message.answer("Укажите telegram_id трейдера:")
    else:
        await state.set_state(SellStates.pay_time)
        await cq.message.answer("5) Время на сделку (мин): 5/10/15/20/25/30")
    await cq.answer()

@router.message(SellStates.audience_params)
async def step_audience_params(message: Message, state: FSMContext):
    data = (message.text or "").strip()
    aud = (await state.get_data())["audience_type"]
    filt = {}
    if aud == "rep":
        parts = data.split()
        if len(parts) == 2:
            filt = {"rep_min": int(parts[0]), "rep_max": int(parts[1])}
        elif len(parts) == 1:
            try:
                v = int(parts[0]); filt = {"rep_min": v}
            except: filt = {"rep_max": int(parts[0])}
        else:
            filt = {}
    elif aud == "per":
        try:
            filt = {"telegram_id": int(data)}
        except:
            await message.answer("Неверный telegram_id.")
            return
    await state.update_data(audience_filter=filt)
    await state.set_state(SellStates.pay_time)
    await message.answer("5) Время на сделку (мин): 5/10/15/20/25/30")

@router.message(SellStates.pay_time)
async def step_pay_time(message: Message, state: FSMContext):
    try:
        mins = int((message.text or "").strip())
        if mins not in (5,10,15,20,25,30): raise ValueError
        await state.update_data(pay_mins=mins)
        await state.set_state(SellStates.comment_ask)
        await message.answer("6) Комментарий к сделке? (Да/Нет)", reply_markup=InlineKeyboardBuilder().row(
            InlineKeyboardBuilder().button(text="Да", callback_data="cmt:yes").button(text="Нет", callback_data="cmt:no").as_markup().inline_keyboard[0]
        ))
    except Exception:
        await message.answer("Введите одно из значений: 5/10/15/20/25/30.")

@router.callback_query(SellStates.comment_ask, F.data.startswith("cmt:"))
async def step_comment_ask(cq: CallbackQuery, state: FSMContext):
    yn = cq.data.split(":",1)[1]
    if yn == "yes":
        await state.set_state(SellStates.comment_text)
        await cq.message.answer("Введите комментарий (до 1000 символов).")
    else:
        await state.update_data(comment=None)
        await state.set_state(SellStates.warning_toggle)
        await cq.message.answer("7) Добавить предупреждение? (Да/Нет)", reply_markup=InlineKeyboardBuilder().row(
            InlineKeyboardBuilder().button(text="Да", callback_data="warn:yes").button(text="Нет", callback_data="warn:no").as_markup().inline_keyboard[0]
        ))
    await cq.answer()

@router.message(SellStates.comment_text)
async def step_comment_text(message: Message, state: FSMContext):
    txt = (message.text or "").strip()
    if len(txt) > 1000:
        await message.answer("Слишком длинно. До 1000 символов.")
        return
    await state.update_data(comment=txt)
    await state.set_state(SellStates.warning_toggle)
    await message.answer("7) Добавить предупреждение? (Да/Нет)", reply_markup=InlineKeyboardBuilder().row(
        InlineKeyboardBuilder().button(text="Да", callback_data="warn:yes").button(text="Нет", callback_data="warn:no").as_markup().inline_keyboard[0]
    ))

@router.callback_query(SellStates.warning_toggle, F.data.startswith("warn:"))
async def step_warning(cq: CallbackQuery, state: FSMContext):
    yn = cq.data.split(":",1)[1]
    await state.update_data(warning_enabled=(yn=="yes"))
    data = await state.get_data()
    # подтверждение
    await state.set_state(SellStates.confirm)
    s = await get_settings()
    usdt = data["amount_usdt"]; rub = data["amount_rub"]
    txt = (
        "<b>Подтверждение сделки — ПРОДАЖА USDT</b>\n"
        f"Сумма: {rub:.2f} RUB (~{usdt:.2f} USDT)\n"
        f"Вознаграждение (база): {data['base_pct']:.2f}%\n"
        f"Комиссия сервиса: {data.get('service_fee_pct', float(s.service_fee_default_pct)):.2f}%\n"
        f"Аудитория: {data.get('audience_type')}\n"
        f"Комментарий: {data.get('comment') or '-'}\n"
        f"Предупреждение: {'вкл' if data.get('warning_enabled') else 'выкл'}\n"
        f"Время на сделку: {data['pay_mins']} мин"
    )
    b = InlineKeyboardBuilder()
    b.button(text="Опубликовать", callback_data="sell:publish")
    b.button(text="Отмена", callback_data="sell:cancel")
    b.adjust(2)
    await cq.message.answer(txt, reply_markup=b.as_markup())
    await cq.answer()

@router.callback_query(SellStates.confirm, F.data.startswith("sell:"))
async def publish_sell(cq: CallbackQuery, state: FSMContext):
    act = cq.data.split(":",1)[1]
    if act == "cancel":
        await state.clear()
        await cq.message.answer("Отменено.")
        await cq.answer(); return
    data = await state.get_data()
    s = await get_settings()

    # номер сделки
    deal_no = datetime.now(TZ).strftime("%Y%m%d-") + __import__("secrets").token_hex(4).upper()[:7]
    service_fee_pct = float(data.get("service_fee_pct", float(s.service_fee_default_pct)))

    async with async_session() as ss:
        u = await ensure_user(ss, cq.from_user)
        if u.role != RoleEnum.admin:
            await cq.answer("Только для администратора", show_alert=True); return

        deal = Deal(
            deal_no=deal_no,
            deal_type=DealType.SELL,
            amount_rub=float(data["amount_rub"]),
            amount_usdt_snapshot=float(data["amount_usdt"]),
            base_pct=float(data["base_pct"]),
            service_fee_pct=service_fee_pct,
            audience_type=data["audience_type"],
            audience_filter=json.dumps(data.get("audience_filter") or {}),
            comment=data.get("comment"),
            warning_enabled=bool(data.get("warning_enabled", False)),
            round_secs=int(s.round_secs_default),
            max_tie_rounds=int(s.max_tie_rounds_default),
            status=DealStatus.OPEN,
        )
        ss.add(deal)
        await ss.commit()

    await state.clear()
    await cq.message.answer(f"Сделка опубликована: ПРОДАЖА USDT\n№ <code>{deal_no}</code>\n"
                            f"{data['amount_rub']:.2f} RUB (~{data['amount_usdt']:.2f} USDT)\n"
                            f"База: {data['base_pct']:.2f}% • Комиссия сервиса: {service_fee_pct:.2f}%\n"
                            f"Время на сделку: {data['pay_mins']} мин")

    # Рассылка Этапа 1 + постановка завершения Этапа 1
    from app.handlers.sell_auction import broadcast_stage1
    await broadcast_stage1(int(deal.id))
    await schedule_stage1_end(int(deal.id), after_seconds=int(s.round_secs_default))
    await cq.answer()
```

Теперь нужно исправить импорт в `app/handlers/sell_auction.py`:


```python
# app/handlers/sell_auction.py
from __future__ import annotations
from aiogram import Router, F
from aiogram.types import Message, CallbackQuery
from aiogram.filters import Command
from aiogram.fsm.state import State, StatesGroup
from aiogram.fsm.context import FSMContext
from aiogram.utils.keyboard import InlineKeyboardBuilder
from sqlalchemy import select, and_
from datetime import datetime
from zoneinfo import ZoneInfo
import json

from app.db.base import async_session
from app.db.models import (Deal, DealType, DealStatus, DealParticipant, User, Bid, DealRound)
from app.services.settings import get_settings
from app.services.balance import ensure_usdt_margin
from app.handlers.utils import ensure_user
from app.utils.money import bank_round_2

router = Router(name="sell_auction")
TZ = ZoneInfo("Europe/Amsterdam")

class BidStates(StatesGroup):
    waiting_bid = State()  # пользователь вводит ставку для конкретной сделки

# ===== Этап 1: Рассылка =====
async def eligible_traders(deal: Deal) -> list[int]:
    async with async_session() as s:
        q = select(User.tg_id, User.id, User.is_online, User.balance_usdt).where(
            User.role=="trader", User.is_active==True, User.is_online==True
        )
        rows = (await s.execute(q)).all()
        # фильтры аудитории
        filt = json.loads(deal.audience_filter or "{}")
        out = []
        for tg_id, uid, online, busdt in rows:
            if not online: continue
            if float(busdt) < float(deal.amount_usdt_snapshot): continue
            # карта: допустим наличие карты проверим позже при выборе (или здесь — опционально)
            # репутация
            if deal.audience_type == "rep":
                rep_q = await s.execute(select(User.rep).where(User.id==uid))
                rep = int(rep_q.scalar() or 0)
                if "rep_min" in filt and rep < int(filt["rep_min"]): continue
                if "rep_max" in filt and rep > int(filt["rep_max"]): continue
            if deal.audience_type == "personal":
                if int(filt.get("telegram_id", 0)) != int(tg_id): continue
            out.append(int(tg_id))
        return out

def stage1_kb(deal_id: int):
    b = InlineKeyboardBuilder()
    b.button(text="Принять сделку (+1 REP)", callback_data=f"sell1:accept:{deal_id}")
    b.button(text="Отклонить сделку (-2 REP)", callback_data=f"sell1:decline:{deal_id}")
    b.button(text="⏳ ТАЙМЕР", callback_data="noop")
    b.adjust(1,1,1)
    return b.as_markup()

async def broadcast_stage1(deal_id: int):
    from app.bot import create_bot_and_dp
    from app.utils.money import bank_round_2
    bot, _ = create_bot_and_dp("")
    async with async_session() as s:
        d = await s.get(Deal, deal_id)
        sset = await get_settings()
        # готовим текст
        max_reward = 0.0
        if float(d.base_pct) > 0:
            max_reward = bank_round_2(float(d.amount_rub) * float(d.base_pct)/100.0)
        txt = (
            "<b>ВЫ УЧАСТВУЕТЕ В АУКЦИОНЕ!</b>\n"
            "Вид сделки: <b>ПРОДАЖА USDT</b>\n"
            f"Номер: <code>{d.deal_no}</code>\n"
            f"Вознаграждение (база): {float(d.base_pct):.2f}%\n"
            f"Сумма: {float(d.amount_rub):.2f} RUB (~{float(d.amount_usdt_snapshot):.2f} USDT)\n"
            f"Макс. вознаграждение (RUB): {max_reward:.2f}\n"
            f"Комиссия сервиса: {float(d.service_fee_pct):.2f}%\n"
            f"Время сделки: {int(sset.round_secs_default)} сек для Этапа 1; оплата: {int( (d.pay_deadline_at is not None) or 0)}\n"
            + (f"\n<b>Комментарий:</b>\n{d.comment}\n" if d.comment else "") +
            ("\n<b>!ПРЕДУПРЕЖДЕНИЕ!</b>\n!Перевод только на карту трейдера!\n!Перевод с другого банка — риск задержек/комиссий!\n" if d.warning_enabled else "") +
            "\nДИСКЛЕЙМЕР"
        )
        # отправка
        tg_ids = await eligible_traders(d)
        for tg_id in tg_ids:
            try:
                await bot.send_message(tg_id, txt, reply_markup=stage1_kb(d.id))
            except Exception:
                continue

@router.callback_query(F.data.startswith("sell1:"))
async def stage1_click(cq: CallbackQuery):
    _, action, deal_id_s = cq.data.split(":",2)
    deal_id = int(deal_id_s)
    async with async_session() as s:
        u = await ensure_user(s, cq.from_user)
        d = await s.get(Deal, deal_id)
        if not d or d.status != DealStatus.OPEN:
            await cq.answer("Сделка недоступна.", show_alert=True); return
        # маржинальное требование по USDT
        if not await ensure_usdt_margin(u.id, float(d.amount_usdt_snapshot)):
            await cq.answer("Недостаточно USDT для участия.", show_alert=True); return
        # записываем участие
        exist = await s.scalar(select(DealParticipant).where(DealParticipant.deal_id==deal_id, DealParticipant.user_id==u.id))
        if not exist:
            p = DealParticipant(deal_id=deal_id, user_id=u.id, accepted=(action=="accept"))
            s.add(p)
        else:
            exist.accepted = (action=="accept")
        # REP
        if action == "accept": u.rep += 1
        else: u.rep -= 2
        await s.commit()
    if action == "accept":
        await cq.message.answer("Отлично! Вы получили +1 REP. Ждите второй этап… ⏳")
    else:
        await cq.message.answer("Очень жаль: −2 REP. Ожидайте другие сделки.")
    await cq.answer()

# ===== Этап 2: приём ставок (FSM) =====
def bid_range_hint(base_pct: float) -> str:
    lo, hi = -5.00, base_pct
    return f"Введите вашу ставку в диапазоне [{lo:.2f}; {hi:.2f}] с шагом 0.01"

@router.message(Command("bid"))
async def bid_help(message: Message):
    await message.answer("Команда для ставки активируется автоматически в Этапе 2.")

# Воркфлоу Этапа 2: по старту раунда воркер создаёт DealRound; мы шлём допущенным инструкцию «введите ставку»
async def notify_round_start(deal_id: int, round_number: int):
    from app.bot import create_bot_and_dp
    bot, _ = create_bot_and_dp("")
    async with async_session() as s:
        d = await s.get(Deal, deal_id)
        if not d: return
        # список допущенных (accepted)
        rows = await s.execute(select(DealParticipant, User.tg_id).join(User, DealParticipant.user_id==User.id)
                               .where(DealParticipant.deal_id==deal_id, DealParticipant.accepted==True))
        for p, tg_id in rows.all():
            try:
                await bot.send_message(int(tg_id),
                    f"<b>АУКЦИОН НАЧАЛСЯ — РАУНД {round_number}</b>\n"
                    f"{bid_range_hint(float(d.base_pct))}\n"
                    f"Отправьте число (например 0.25 или -1.50).")
            except Exception:
                continue

@router.message(BidStates.waiting_bid)
async def accept_bid(message: Message, state: FSMContext):
    data = await state.get_data()
    deal_id = int(data.get("deal_id"))
    try:
        v = float((message.text or "").replace(",", "."))
    except:
        await message.answer("Нужно число. Пример: 0.25 или -2.00"); return
    async with async_session() as s:
        d = await s.get(Deal, deal_id)
        if not d or d.status != DealStatus.BIDDING:
            await message.answer("Приём ставок закрыт."); return
        lo, hi = -5.00, float(d.base_pct)
        # валидация диапазона и шага 0.01
        if v < lo or v > hi or abs(round(v*100) - v*100) > 1e-9:
            await message.answer(bid_range_hint(float(d.base_pct))); return
        # текущий раунд
        r = await s.scalar(select(DealRound).where(DealRound.deal_id==deal_id).order_by(DealRound.round_number.desc()).limit(1))
        if not r:
            await message.answer("Техническая пауза. Попробуйте позже."); return
        # сохранить ставку (последняя перезаписывает)
        exist = await s.scalar(select(Bid).where(Bid.deal_id==deal_id, Bid.round_number==r.round_number, Bid.user_id== (await s.scalar(select(User.id).where(User.tg_id==message.from_user.id)))))
        if exist:
            exist.pct = round(v,2)
        else:
            uid = await s.scalar(select(User.id).where(User.tg_id==message.from_user.id))
            s.add(Bid(deal_id=deal_id, round_number=r.round_number, user_id=uid, pct=round(v,2)))
        await s.commit()
    await message.answer("Ставка принята.")
```

Теперь нужно исправить импорт в `app/handlers/sell_winner.py`:


```python
# app/handlers/sell_winner.py
from __future__ import annotations
from aiogram import Router, F
from aiogram.filters import Command
from aiogram.types import Message, CallbackQuery
from aiogram.utils.keyboard import InlineKeyboardBuilder
from sqlalchemy import select, update
from datetime import datetime, timedelta
from zoneinfo import ZoneInfo

from app.db.base import async_session
from app.db.models import (Deal, DealStatus, TraderProfile, TraderCard, User)
from app.handlers.utils import ensure_user
from app.utils.validation import mask_card
from app.services.balance import release_usdt, consume_reserved_usdt
from app.utils.money import bank_round_2
from app.scheduler import schedule_trader_confirm_window

router = Router(name="sell_winner")
TZ = ZoneInfo("Europe/Amsterdam")

def cards_kb(cards: list[TraderCard], deal_id: int):
    b = InlineKeyboardBuilder()
    for c in cards:
        bank_name = c.bank.value if c.bank.name != "OTHER" else (c.bank_other_name or "ДРУГОЙ БАНК")
        b.button(text=f"{bank_name} • {mask_card(c.card_number)}", callback_data=f"pick:{deal_id}:{c.id}")
    b.adjust(1); return b.as_markup()

@router.message(Command("pick_card"))
async def pick_card_cmd(message: Message):
    # /pick_card <deal_id>
    parts = (message.text or "").split()
    if len(parts) != 2:
        await message.answer("Использование: /pick_card <deal_id>"); return
    deal_id = int(parts[1])
    async with async_session() as s:
        u = await ensure_user(s, message.from_user)
        d = await s.get(Deal, deal_id)
        if not d or d.winner_user_id != u.id:
            await message.answer("Недоступно."); return
        # карты
        prof = await s.scalar(select(TraderProfile).where(TraderProfile.user_id==u.id))
        cards = (await s.execute(select(TraderCard).where(TraderCard.profile_id==prof.id))).scalars().all()
        if not cards:
            await message.answer("У вас нет карт. Обратитесь к администратору."); return
        await message.answer("Выберите карту для получения RUB:", reply_markup=cards_kb(cards, deal_id))

@router.callback_query(F.data.startswith("pick:"))
async def pick_card_cb(cq: CallbackQuery):
    _, deal_id_s, card_id_s = cq.data.split(":",2)
    deal_id, card_id = int(deal_id_s), int(card_id_s)
    async with async_session() as s:
        u = await ensure_user(s, cq.from_user)
        d = await s.get(Deal, deal_id)
        if not d or d.winner_user_id != u.id:
            await cq.answer("Недоступно.", show_alert=True); return
        c = await s.get(TraderCard, card_id)
        if not c:
            await cq.answer("Карта не найдена.", show_alert=True); return
        # Снэпшоты карты
        bank_name = c.bank.value if c.bank.name != "OTHER" else (c.bank_other_name or "ДРУГОЙ БАНК")
        d.winner_card_id = c.id
        d.winner_card_bank = bank_name
        d.winner_card_mask = mask_card(c.card_number)
        d.winner_card_holder = c.holder_name
        d.status = DealStatus.WAITING_ADMIN_TRANSFER
        await s.commit()
    await cq.message.answer(
        "<b>Карта сохранена</b>\n"
        f"Банк: {d.winner_card_bank}\n"
        f"Карта: {d.winner_card_mask}\n"
        f"Держатель: {d.winner_card_holder}\n\n"
        "Ожидайте перевода от администратора."
    )
    # уведомить администратора(ов)
    from app.config import settings
    from app.bot import create_bot_and_dp
    bot, _ = create_bot_and_dp("")
    text_admin = (
        "<b>ПРОДАЖА USDT — переведите RUB победителю</b>\n"
        f"Сделка № <code>{d.deal_no}</code>\n"
        f"Сумма: {float(d.amount_rub):.2f} RUB (~{float(d.amount_usdt_snapshot):.2f} USDT)\n"
        f"Карта: {d.winner_card_bank} • {d.winner_card_mask} • {d.winner_card_holder}\n"
        f"Комментарий: {d.comment or '-'}"
    )
    for admin in settings.admins:
        try:
            await bot.send_message(admin, text_admin, reply_markup=InlineKeyboardBuilder().row(
                InlineKeyboardBuilder().button(text="Перевод выполнен", callback_data=f"adm:paid:{deal_id}"),
                InlineKeyboardBuilder().button(text="Проблема с картой", callback_data=f"adm:card:{deal_id}")
            ).as_markup())
        except Exception:
            continue
    await cq.answer()

@router.callback_query(F.data.startswith("adm:paid:"))
async def admin_paid(cq: CallbackQuery):
    deal_id = int(cq.data.split(":",2)[2])
    async with async_session() as s:
        d = await s.get(Deal, deal_id)
        if not d: return await cq.answer()
        d.status = DealStatus.WAITING_TRADER_CONFIRM
        await s.commit()
    # окно подтверждения трейдера (10 мин)
    await schedule_trader_confirm_window(deal_id, after_minutes=10)
    await cq.message.answer("Ок. Ожидаем подтверждение от трейдера.")
    await cq.answer()

@router.callback_query(F.data.startswith("adm:card:"))
async def admin_card_issue(cq: CallbackQuery):
    deal_id = int(cq.data.split(":",2)[2])
    async with async_session() as s:
        d = await s.get(Deal, deal_id)
        if not d: return await cq.answer()
        # пауза таймера не реализована детально — можно просто отложить задачу вручную
        await cq.message.answer("Отмечено. Свяжитесь с трейдером для смены карты.")
    await cq.answer()

def winner_actions_kb(deal_id: int):
    b = InlineKeyboardBuilder()
    b.button(text="Я ПОЛУЧИЛ ПЕРЕВОД", callback_data=f"win:got:{deal_id}")
    b.button(text="СМЕНИТЬ КАРТУ", callback_data=f"win:card:{deal_id}")
    b.button(text="ОТМЕНА СДЕЛКИ −200 RUB", callback_data=f"win:cancel:{deal_id}")
    b.button(text="ОПЕРАТОР", callback_data=f"win:op:{deal_id}")
    b.adjust(1,2,1); return b.as_markup()

@router.callback_query(F.data.startswith("win:got:"))
async def winner_got_money(cq: CallbackQuery):
    deal_id = int(cq.data.split(":",2)[2])
    async with async_session() as s:
        d = await s.get(Deal, deal_id)
        if not d or d.status not in (DealStatus.WAITING_ADMIN_TRANSFER, DealStatus.WAITING_TRADER_CONFIRM):
            await cq.answer("Недоступно.", show_alert=True); return
        # финальные расчёты
        reward_rub = bank_round_2(float(d.amount_rub) * float(d.winner_bid_pct)/100.0)
        fee_rub = bank_round_2(reward_rub * float(d.service_fee_pct)/100.0) if reward_rub > 0 else 0.0
        # списать резерв USDT
        await consume_reserved_usdt(int(d.winner_user_id), float(d.amount_usdt_snapshot))
        # применить вознаграждение к RUB-балансу победителя
        u = await s.get(User, int(d.winner_user_id))
        if reward_rub >= 0:
            u.balance_rub = float(u.balance_rub) + (reward_rub - fee_rub)
        else:
            u.balance_rub = float(u.balance_rub) - abs(reward_rub)
        d.status = DealStatus.COMPLETED
        await s.commit()
    await cq.message.answer("Сделка завершена. Спасибо!")
    await cq.answer()

@router.callback_query(F.data.startswith("win:cancel:"))
async def winner_cancel(cq: CallbackQuery):
    deal_id = int(cq.data.split(":",2)[2])
    async with async_session() as s:
        d = await s.get(Deal, deal_id)
        if not d: return
        # штраф −200 RUB, резерв USDT вернуть
        u = await s.get(User, int(d.winner_user_id))
        u.balance_rub = float(u.balance_rub) - 200.0
        await release_usdt(int(d.winner_user_id), float(d.amount_usdt_snapshot))
        d.status = DealStatus.CANCELLED_BY_TRADER
        await s.commit()
    await cq.message.answer("Сделка отменена. Штраф −200 RUB применён.")
    await cq.answer()

@router.callback_query(F.data.startswith("win:card:"))
async def winner_change_card(cq: CallbackQuery):
    # простая переотправка выбора карт
    deal_id = int(cq.data.split(":",2)[2])
    async with async_session() as s:
        u = await ensure_user(s, cq.from_user)
        d = await s.get(Deal, deal_id)
        prof = await s.scalar(select(TraderProfile).where(TraderProfile.user_id==u.id))
        cards = (await s.execute(select(TraderCard).where(TraderCard.profile_id==prof.id))).scalars().all()
    await cq.message.answer("Выберите новую карту:", reply_markup=cards_kb(cards, deal_id))
    await cq.answer()
```

Теперь нужно исправить импорт в `app/handlers/admin_deals_sell.py`:


```python
# app/handlers/admin_deals_sell.py
from __future__ import annotations
from aiogram import Router, F
from aiogram.filters import Command
from aiogram.fsm.state import State, StatesGroup
from aiogram.fsm.context import FSMContext
from aiogram.types import Message, CallbackQuery
from aiogram.utils.keyboard import InlineKeyboardBuilder
from sqlalchemy import select
from datetime import datetime, timedelta
from zoneinfo import ZoneInfo
import json

from app.config import settings
from app.db.base import async_session
from app.db.models import RoleEnum, User, Deal, DealType, DealStatus
from app.handlers.utils import ensure_user
from app.services.settings import get_settings
from app.utils.money import bank_round_2
from app.utils.validation import validate_decimal_range_step
from app.scheduler import schedule_stage1_end

router = Router(name="admin_deals_sell")
TZ = ZoneInfo("Europe/Amsterdam")

class SellStates(StatesGroup):
    amount_rub = State()
    base_pct = State()
    service_fee = State()
    audience = State()
    audience_params = State()
    pay_time = State()
    comment_ask = State()
    comment_text = State()
    warning_toggle = State()
    confirm = State()

def kb_yesno(cb_yes: str, cb_no: str):
    b = InlineKeyboardBuilder()
    b.button(text="Да", callback_data=cb_yes)
    b.button(text="Нет", callback_data=cb_no)
    b.adjust(2); return b.as_markup()

def kb_audience():
    b = InlineKeyboardBuilder()
    b.button(text="Для всех (онлайн + USDT маржа + карта)", callback_data="aud:all")
    b.button(text="По рейтингу", callback_data="aud:rep")
    b.button(text="Персонально", callback_data="aud:per")
    b.adjust(1)
    return b.as_markup()

@router.message(Command("sell"))
async def sell_menu(message: Message, state: FSMContext):
    async with async_session() as s:
        u = await ensure_user(s, message.from_user)
        if u.role != RoleEnum.admin:
            await message.answer("Доступно только администратору.")
            return
    await state.clear()
    await state.set_state(SellStates.amount_rub)
    await message.answer("1) Введите сумму сделки в RUB:")

@router.message(SellStates.amount_rub)
async def step_amount(message: Message, state: FSMContext):
    try:
        rub = float((message.text or "").replace(" ", "").replace(",", "."))
        if rub <= 0: raise ValueError
        s = await get_settings()
        usdt = bank_round_2(rub / float(s.rub_per_usdt))
        await state.update_data(amount_rub=bank_round_2(rub), amount_usdt=usdt)
        await state.set_state(SellStates.base_pct)
        await message.answer(f"USDT эквивалент: ~ {usdt:.2f}\n2) Вознаграждение трейдера, % (−5.00..+25.00):")
    except Exception:
        await message.answer("Некорректная сумма. Повторите ввод.")

@router.message(SellStates.base_pct)
async def step_base_pct(message: Message, state: FSMContext):
    try:
        v = float((message.text or "").replace(",", "."))
        if not validate_decimal_range_step(v, -5.00, 25.00, 0.01): raise ValueError
        await state.update_data(base_pct=round(v,2))
        s = await get_settings()
        if s.service_fee_overridable:
            await state.set_state(SellStates.service_fee)
            await message.answer(f"3) Комиссия сервиса, % (диапазон {s.service_fee_min_pct:.2f}..{s.service_fee_max_pct:.2f}), шаг 0.01.\nПо умолчанию {s.service_fee_default_pct:.2f}%")
        else:
            await state.update_data(service_fee_pct=float(s.service_fee_default_pct))
            await state.set_state(SellStates.audience)
            await message.answer("4) Выберите аудиторию:", reply_markup=kb_audience())
    except Exception:
        await message.answer("Неверное значение. Введите в диапазоне −5.00..+25.00 с шагом 0.01.")

@router.message(SellStates.service_fee)
async def step_service_fee(message: Message, state: FSMContext):
    from app.services.settings import get_settings
    s = await get_settings()
    try:
        v = float((message.text or "").replace(",", "."))
        if not validate_decimal_range_step(v, float(s.service_fee_min_pct), float(s.service_fee_max_pct), 0.01): raise ValueError
        await state.update_data(service_fee_pct=round(v,2))
        await state.set_state(SellStates.audience)
        await message.answer("4) Выберите аудиторию:", reply_markup=kb_audience())
    except Exception:
        await message.answer(f"Неверно. Введите значение в диапазоне {float(s.service_fee_min_pct):.2f}..{float(s.service_fee_max_pct):.2f} с шагом 0.01.")

@router.callback_query(SellStates.audience, F.data.startswith("aud:"))
async def step_audience(cq: CallbackQuery, state: FSMContext):
    mode = cq.data.split(":",1)[1]
    await state.update_data(audience_type=mode)
    if mode == "rep":
        await state.set_state(SellStates.audience_params)
        await cq.message.answer("Укажите REP диапазон: 'от до' (можно оставить пустым один конец). Пример: '10 100' или '10' или ' 100'")
    elif mode == "per":
        await state.set_state(SellStates.audience_params)
        await cq.message.answer("Укажите telegram_id трейдера:")
    else:
        await state.set_state(SellStates.pay_time)
        await cq.message.answer("5) Время на сделку (мин): 5/10/15/20/25/30")
    await cq.answer()

@router.message(SellStates.audience_params)
async def step_audience_params(message: Message, state: FSMContext):
    data = (message.text or "").strip()
    aud = (await state.get_data())["audience_type"]
    filt = {}
    if aud == "rep":
        parts = data.split()
        if len(parts) == 2:
            filt = {"rep_min": int(parts[0]), "rep_max": int(parts[1])}
        elif len(parts) == 1:
            try:
                v = int(parts[0]); filt = {"rep_min": v}
            except: filt = {"rep_max": int(parts[0])}
        else:
            filt = {}
    elif aud == "per":
        try:
            filt = {"telegram_id": int(data)}
        except:
            await message.answer("Неверный telegram_id.")
            return
    await state.update_data(audience_filter=filt)
    await state.set_state(SellStates.pay_time)
    await message.answer("5) Время на сделку (мин): 5/10/15/20/25/30")

@router.message(SellStates.pay_time)
async def step_pay_time(message: Message, state: FSMContext):
    try:
        mins = int((message.text or "").strip())
        if mins not in (5,10,15,20,25,30): raise ValueError
        await state.update_data(pay_mins=mins)
        await state.set_state(SellStates.comment_ask)
        await message.answer("6) Комментарий к сделке? (Да/Нет)", reply_markup=InlineKeyboardBuilder().row(
            InlineKeyboardBuilder().button(text="Да", callback_data="cmt:yes").button(text="Нет", callback_data="cmt:no").as_markup().inline_keyboard[0]
        ))
    except Exception:
        await message.answer("Введите одно из значений: 5/10/15/20/25/30.")

@router.callback_query(SellStates.comment_ask, F.data.startswith("cmt:"))
async def step_comment_ask(cq: CallbackQuery, state: FSMContext):
    yn = cq.data.split(":",1)[1]
    if yn == "yes":
        await state.set_state(SellStates.comment_text)
        await cq.message.answer("Введите комментарий (до 1000 символов).")
    else:
        await state.update_data(comment=None)
        await state.set_state(SellStates.warning_toggle)
        await cq.message.answer("7) Добавить предупреждение? (Да/Нет)", reply_markup=InlineKeyboardBuilder().row(
            InlineKeyboardBuilder().button(text="Да", callback_data="warn:yes").button(text="Нет", callback_data="warn:no").as_markup().inline_keyboard[0]
        ))
    await cq.answer()

@router.message(SellStates.comment_text)
async def step_comment_text(message: Message, state: FSMContext):
    txt = (message.text or "").strip()
    if len(txt) > 1000:
        await message.answer("Слишком длинно. До 1000 символов.")
        return
    await state.update_data(comment=txt)
    await state.set_state(SellStates.warning_toggle)
    await message.answer("7) Добавить предупреждение? (Да/Нет)", reply_markup=InlineKeyboardBuilder().row(
        InlineKeyboardBuilder().button(text="Да", callback_data="warn:yes").button(text="Нет", callback_data="warn:no").as_markup().inline_keyboard[0]
    ))

@router.callback_query(SellStates.warning_toggle, F.data.startswith("warn:"))
async def step_warning(cq: CallbackQuery, state: FSMContext):
    yn = cq.data.split(":",1)[1]
    await state.update_data(warning_enabled=(yn=="yes"))
    data = await state.get_data()
    # подтверждение
    await state.set_state(SellStates.confirm)
    s = await get_settings()
    usdt = data["amount_usdt"]; rub = data["amount_rub"]
    txt = (
        "<b>Подтверждение сделки — ПРОДАЖА USDT</b>\n"
        f"Сумма: {rub:.2f} RUB (~{usdt:.2f} USDT)\n"
        f"Вознаграждение (база): {data['base_pct']:.2f}%\n"
        f"Комиссия сервиса: {data.get('service_fee_pct', float(s.service_fee_default_pct)):.2f}%\n"
        f"Аудитория: {data.get('audience_type')}\n"
        f"Комментарий: {data.get('comment') or '-'}\n"
        f"Предупреждение: {'вкл' if data.get('warning_enabled') else 'выкл'}\n"
        f"Время на сделку: {data['pay_mins']} мин"
    )
    b = InlineKeyboardBuilder()
    b.button(text="Опубликовать", callback_data="sell:publish")
    b.button(text="Отмена", callback_data="sell:cancel")
    b.adjust(2)
    await cq.message.answer(txt, reply_markup=b.as_markup())
    await cq.answer()

@router.callback_query(SellStates.confirm, F.data.startswith("sell:"))
async def publish_sell(cq: CallbackQuery, state: FSMContext):
    act = cq.data.split(":",1)[1]
    if act == "cancel":
        await state.clear()
        await cq.message.answer("Отменено.")
        await cq.answer(); return
    data = await state.get_data()
    s = await get_settings()

    # номер сделки
    deal_no = datetime.now(TZ).strftime("%Y%m%d-") + __import__("secrets").token_hex(4).upper()[:7]
    service_fee_pct = float(data.get("service_fee_pct", float(s.service_fee_default_pct)))

    async with async_session() as ss:
        u = await ensure_user(ss, cq.from_user)
        if u.role != RoleEnum.admin:
            await cq.answer("Только для администратора", show_alert=True); return

        deal = Deal(
            deal_no=deal_no,
            deal_type=DealType.SELL,
            amount_rub=float(data["amount_rub"]),
            amount_usdt_snapshot=float(data["amount_usdt"]),
            base_pct=float(data["base_pct"]),
            service_fee_pct=service_fee_pct,
            audience_type=data["audience_type"],
            audience_filter=json.dumps(data.get("audience_filter") or {}),
            comment=data.get("comment"),
            warning_enabled=bool(data.get("warning_enabled", False)),
            round_secs=int(s.round_secs_default),
            max_tie_rounds=int(s.max_tie_rounds_default),
            status=DealStatus.OPEN,
        )
        ss.add(deal)
        await ss.commit()

    await state.clear()
    await cq.message.answer(f"Сделка опубликована: ПРОДАЖА USDT\n№ <code>{deal_no}</code>\n"
                            f"{data['amount_rub']:.2f} RUB (~{data['amount_usdt']:.2f} USDT)\n"
                            f"База: {data['base_pct']:.2f}% • Комиссия сервиса: {service_fee_pct:.2f}%\n"
                            f"Время на сделку: {data['pay_mins']} мин")

    # Рассылка Этапа 1 + постановка завершения Этапа 1
    from app.handlers.sell_auction import broadcast_stage1
    await broadcast_stage1(int(deal.id))
    await schedule_stage1_end(int(deal.id), after_seconds=int(s.round_secs_default))
    await cq.answer()
```

Теперь нужно исправить импорт в `app/handlers/sell_auction.py`:


```python
# app/handlers/sell_auction.py
from __future__ import annotations
from aiogram import Router, F
from aiogram.types import Message, CallbackQuery
from aiogram.filters import Command
from aiogram.fsm.state import State, StatesGroup
from aiogram.fsm.context import FSMContext
from aiogram.utils.keyboard import InlineKeyboardBuilder
from sqlalchemy import select, and_
from datetime import datetime
from zoneinfo import ZoneInfo
import json

from app.db.base import async_session
from app.db.models import (Deal, DealType, DealStatus, DealParticipant, User, Bid, DealRound)
from app.services.settings import get_settings
from app.services.balance import ensure_usdt_margin
from app.handlers.utils import ensure_user
from app.utils.money import bank_round_2

router = Router(name="sell_auction")
TZ = ZoneInfo("Europe/Amsterdam")

class BidStates(StatesGroup):
    waiting_bid = State()  # пользователь вводит ставку для конкретной сделки

# ===== Этап 1: Рассылка =====
async def eligible_traders(deal: Deal) -> list[int]:
    async with async_session() as s:
        q = select(User.tg_id, User.id, User.is_online, User.balance_usdt).where(
            User.role=="trader", User.is_active==True, User.is_online==True
        )
        rows = (await s.execute(q)).all()
        # фильтры аудитории
        filt = json.loads(deal.audience_filter or "{}")
        out = []
        for tg_id, uid, online, busdt in rows:
            if not online: continue
            if float(busdt) < float(deal.amount_usdt_snapshot): continue
            # карта: допустим наличие карты проверим позже при выборе (или здесь — опционально)
            # репутация
            if deal.audience_type == "rep":
                rep_q = await s.execute(select(User.rep).where(User.id==uid))
                rep = int(rep_q.scalar() or 0)
                if "rep_min" in filt and rep < int(filt["rep_min"]): continue
                if "rep_max" in filt and rep > int(filt["rep_max"]): continue
            if deal.audience_type == "personal":
                if int(filt.get("telegram_id", 0)) != int(tg_id): continue
            out.append(int(tg_id))
        return out

def stage1_kb(deal_id: int):
    b = InlineKeyboardBuilder()
    b.button(text="Принять сделку (+1 REP)", callback_data=f"sell1:accept:{deal_id}")
    b.button(text="Отклонить сделку (-2 REP)", callback_data=f"sell1:decline:{deal_id}")
    b.button(text="⏳ ТАЙМЕР", callback_data="noop")
    b.adjust(1,1,1)
    return b.as_markup()

async def broadcast_stage1(deal_id: int):
    from app.bot import create_bot_and_dp
    from app.utils.money import bank_round_2
    bot, _ = create_bot_and_dp("")
    async with async_session() as s:
        d = await s.get(Deal, deal_id)
        sset = await get_settings()
        # готовим текст
        max_reward = 0.0
        if float(d.base_pct) > 0:
            max_reward = bank_round_2(float(d.amount_rub) * float(d.base_pct)/100.0)
        txt = (
            "<b>ВЫ УЧАСТВУЕТЕ В АУКЦИОНЕ!</b>\n"
            "Вид сделки: <b>ПРОДАЖА USDT</b>\n"
            f"Номер: <code>{d.deal_no}</code>\n"
            f"Вознаграждение (база): {float(d.base_pct):.2f}%\n"
            f"Сумма: {float(d.amount_rub):.2f} RUB (~{float(d.amount_usdt_snapshot):.2f} USDT)\n"
            f"Макс. вознаграждение (RUB): {max_reward:.2f}\n"
            f"Комиссия сервиса: {float(d.service_fee_pct):.2f}%\n"
            f"Время сделки: {int(sset.round_secs_default)} сек для Этапа 1; оплата: {int( (d.pay_deadline_at is not None) or 0)}\n"
            + (f"\n<b>Комментарий:</b>\n{d.comment}\n" if d.comment else "") +
            ("\n<b>!ПРЕДУПРЕЖДЕНИЕ!</b>\n!Перевод только на карту трейдера!\n!Перевод с другого банка — риск задержек/комиссий!\n" if d.warning_enabled else "") +
            "\nДИСКЛЕЙМЕР"
        )
        # отправка
        tg_ids = await eligible_traders(d)
        for tg_id in tg_ids:
            try:
                await bot.send_message(tg_id, txt, reply_markup=stage1_kb(d.id))
            except Exception:
                continue

@router.callback_query(F.data.startswith("sell1:"))
async def stage1_click(cq: CallbackQuery):
    _, action, deal_id_s = cq.data.split(":",2)
    deal_id = int(deal_id_s)
    async with async_session() as s:
        u = await ensure_user(s, cq.from_user)
        d = await s.get(Deal, deal_id)
        if not d or d.status != DealStatus.OPEN:
            await cq.answer("Сделка недоступна.", show_alert=True); return
        # маржинальное требование по USDT
        if not await ensure_usdt_margin(u.id, float(d.amount_usdt_snapshot)):
            await cq.answer("Недостаточно USDT для участия.", show_alert=True); return
        # записываем участие
        exist = await s.scalar(select(DealParticipant).where(DealParticipant.deal_id==deal_id, DealParticipant.user_id==u.id))
        if not exist:
            p = DealParticipant(deal_id=deal_id, user_id=u.id, accepted=(action=="accept"))
            s.add(p)
        else:
            exist.accepted = (action=="accept")
        # REP
        if action == "accept": u.rep += 1
        else: u.rep -= 2
        await s.commit()
    if action == "accept":
        await cq.message.answer("Отлично! Вы получили +1 REP. Ждите второй этап… ⏳")
    else:
        await cq.message.answer("Очень жаль: −2 REP. Ожидайте другие сделки.")
    await cq.answer()

# ===== Этап 2: приём ставок (FSM) =====
def bid_range_hint(base_pct: float) -> str:
    lo, hi = -5.00, base_pct
    return f"Введите вашу ставку в диапазоне [{lo:.2f}; {hi:.2f}] с шагом 0.01"

@router.message(Command("bid"))
async def bid_help(message: Message):
    await message.answer("Команда для ставки активируется автоматически в Этапе 2.")

# Воркфлоу Этапа 2: по старту раунда воркер создаёт DealRound; мы шлём допущенным инструкцию «введите ставку»
async def notify_round_start(deal_id: int, round_number: int):
    from app.bot import create_bot_and_dp
    bot, _ = create_bot_and_dp("")
    async with async_session() as s:
        d = await s.get(Deal, deal_id)
        if not d: return
        # список допущенных (accepted)
        rows = await s.execute(select(DealParticipant, User.tg_id).join(User, DealParticipant.user_id==User.id)
                               .where(DealParticipant.deal_id==deal_id, DealParticipant.accepted==True))
        for p, tg_id in rows.all():
            try:
                await bot.send_message(int(tg_id),
                    f"<b>АУКЦИОН НАЧАЛСЯ — РАУНД {round_number}</b>\n"
                    f"{bid_range_hint(float(d.base_pct))}\n"
                    f"Отправьте число (например 0.25 или -1.50).")
            except Exception:
                continue

@router.message(BidStates.waiting_bid)
async def accept_bid(message: Message, state: FSMContext):
    data = await state.get_data()
    deal_id = int(data.get("deal_id"))
    try:
        v = float((message.text or "").replace(",", "."))
    except:
        await message.answer("Нужно число. Пример: 0.25 или -2.00"); return
    async with async_session() as s:
        d = await s.get(Deal, deal_id)
        if not d or d.status != DealStatus.BIDDING:
            await message.answer("Приём ставок закрыт."); return
        lo, hi = -5.00, float(d.base_pct)
        # валидация диапазона и шага 0.01
        if v < lo or v > hi or abs(round(v*100) - v*100) > 1e-9:
            await message.answer(bid_range_hint(float(d.base_pct))); return
        # текущий раунд
        r = await s.scalar(select(DealRound).where(DealRound.deal_id==deal_id).order_by(DealRound.round_number.desc()).limit(1))
        if not r:
            await message.answer("Техническая пауза. Попробуйте позже."); return
        # сохранить ставку (последняя перезаписывает)
        exist = await s.scalar(select(Bid).where(Bid.deal_id==deal_id, Bid.round_number==r.round_number, Bid.user_id== (await s.scalar(select(User.id).where(User.tg_id==message.from_user.id)))))
        if exist:
            exist.pct = round(v,2)
        else:
            uid = await s.scalar(select(User.id).where(User.tg_id==message.from_user.id))
            s.add(Bid(deal_id=deal_id, round_number=r.round_number, user_id=uid, pct=round(v,2)))
        await s.commit()
    await message.answer("Ставка принята.")
```

---

**User**

Почему-то прервалось

